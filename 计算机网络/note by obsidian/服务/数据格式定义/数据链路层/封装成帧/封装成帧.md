## 帧的封装

**封装成帧**（framing），是在一段数据的前后分别添加首部和尾部，构成一个**帧**，又称**组帧**

从物理层过来的数据是比特流，物理层不需要对数据进行区分，只需要传输就够了。但数据链路层就需要分组转发了，必须对数据进行分组，分组则需要在数据中加入能够让数据链路层识别数据分组的界限，因为是对比特流进行区分，所以必须清楚从哪里开始到哪里结束，因此首部和尾部都是很重要的。

一般来说，帧都是由网络驱动所生成，然后通过网卡将其发送到网线上，再由网线进行比特流的传输。实现由数据链路层到物理层的转换。

组帧主要就是解决三个问题，**帧定界**、**帧同步**、**透明传输**

## 帧的界定

数据链路层所发送的每个分组都是一个帧，帧的大小是用帧的首部和尾部去界定的（即首部和尾部的作用为**帧定界**）。考虑到发送时延，发送效率等因素，帧的规定不能太长，也不能太短。**太长发送时延太大，且缓冲区也是有限度的**，**太短发送效率太低**。

### MTU

最大传输单元（Maximum Transmission Unit，MTU），由网卡所限制的（硬件限制），用来规定在链路层传输中的帧或包的最大大小，不同协议规定的MTU大小不同。

>这里的最大长度，仅为数据部分，不包含头部和尾部

MTU本质是数据链路层的协议，但其限制的是上层协议（网络层IP数据包）的大小，如果传来的IP数据包过大，大于MTU，就得对IP数据包进行分片，使其小于MTU。

两台计算机进行通信，其MTU的取值不只是这两台进行通信的计算机的MTU，应该为两台计算机进行通信的**路径中的最小MTU**，这个又称为“路径MTU”

### 识别帧的界定的方法

课本中对于帧定界的描述
>若要传输的数据为可打印的ASCII码组成的文本文件时，对于帧的界定可以使用“**帧定界符**”
>控制字符SOH（Start Of Header）在帧的最前面，表示帧的首部开始
>控制字符EOT（End Of Transmission）在帧的最后面，表示帧的结束

这是帧定界的一种方法

其实帧定界本质就是通过某种方法（加入标识符）来表示或识别帧的开始与结束，以便于帧之间的区分，后面的识别，即**帧同步**。

## 帧同步和透明传输

帧的同步，即接收方能从接收到的二进制比特流中区分出帧的起始和终止。

这里就会出现一个问题，如果以特殊字符对帧的头部和尾部进行界定，那么要传输的信息中出现特殊字符怎么办，**透明传输**就可以解决这个问题！

> 类似C语言中的转义字符“\”一样

## 帧定界的方法

常见的有四种：

- 字符计数法
- 字符填充的首尾定界符法（***这个有涉及到透明传输***）
- 零比特填充的首位标志法（***同样涉及到透明传输***）
- 违规编码法

按照日常使用程度和最小单位来看，能分成两部分
- 日常使用较少，以字符（Byte）为单位
	- 字符计数法
	- 字符填充的首位定界符法
- 日常使用较多，以比特（bit）为单位
	- 零比特填充的首位标志法
	- 违规编码法

#### 字符计数法

帧头部使用一个字符来标明当前帧内共有多少字符（包含其自身的1个字符）

![[image-20230717115430283.png]]

缺点是***计数字段很脆弱，容易在传输过程中发生错误***

#### 字符填充的首尾定界法

使用控制字符SOH作为开头，表示帧的首部开始，控制字符EOT表示帧的结束，转义字符ESC（不是真的“ESC”，是一个字符的代称）实现透明传输。
具体方式为***帧的数据段中出现EOT字符或SOH字符，发送方在每个SOH和EOT前都插入一个ESC字符，以表示转义，接收方接收到后会删除这个ESC字符***
![[image-20230717150201785.png]]

缺点是***实现上较为复杂，使用字符也会有不兼容性***

实现透明传输除了ESC控制字符以外，还可以使用反向不归零编码

#### 零比特填充的首位标志法

使用比特作为最小信息单位，以“01111110”作为帧的开头和结尾
透明传输的实现为，***当发送方在数据段中遇到连续5个“1”，会在后面插入一个“0”，接收方采用逆操作，每次遇到5个“1”，删除其后面的一个“0”***
![[image-20230717151445057.png]]

#### 违规编码法

较为特殊，比如物理层使用曼切斯特编码，比特“1”编码为“高-低”电平对，比特“0”编码为“低-高”电平对，“高-高”电平对和“低-低”电平对没有采用，可以借用这些违规的编码定界帧的起始和终止，也就不用担心透明传输的问题了
局域网IEEE802标准就采用了这种方法。
但这种方式只能用于有冗余编码的特殊编码环境。