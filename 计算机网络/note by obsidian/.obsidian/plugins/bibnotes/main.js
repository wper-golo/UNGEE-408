/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => MyPlugin
});
var fs2 = __toModule(require("fs"));

// node_modules/debugout.js/dist/debugout.min.js
var __assign = function() {
  return (__assign = Object.assign || function(t) {
    for (var e, o = 1, i = arguments.length; o < i; o++)
      for (var r in e = arguments[o])
        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
    return t;
  }).apply(this, arguments);
};
var debugoutDefaults = { realTimeLoggingOn: true, useTimestamps: false, includeSessionMetadata: true, useLocalStorage: false, recordLogs: true, autoTrim: true, maxLines: 3e3, tailNumLines: 25, maxDepth: 20, logFilename: "debugout.txt", localStorageKey: "debugout.js", indent: "  ", quoteStrings: true };
var Debugout = function() {
  function t(t2) {
    var e = this;
    this.indent = "  ", this.tailNumLines = 25, this.output = "", this.version = function() {
      return "1.1.0";
    }, this.indentsForDepth = function(t3) {
      return e.indent.repeat(Math.max(t3, 0));
    }, this.trace = function() {
      return console.trace();
    }, this.time = function() {
      return console.time();
    }, this.timeEnd = function() {
      return console.timeEnd();
    };
    var o = __assign(__assign({}, debugoutDefaults), t2);
    for (var i in o)
      o[i] !== void 0 && (this[i] = o[i]);
    if (this.useLocalStorage && window && window.localStorage) {
      var r = this.load();
      if (r) {
        this.output = r.log, this.startTime = new Date(r.startTime);
        var n = new Date(r.lastLog);
        this.logMetadata("Last session end: " + r.lastLog), this.logMetadata("Last " + this.formatSessionDuration(this.startTime, n)), this.startLog();
      } else
        this.startLog();
    } else
      this.useLocalStorage = false, this.startLog();
  }
  return t.prototype.startLog = function() {
    this.startTime = new Date(), this.logMetadata("Session started: " + this.formatDate(this.startTime));
  }, t.prototype.recordLog = function() {
    for (var t2 = this, e = [], o = 0; o < arguments.length; o++)
      e[o] = arguments[o];
    if (this.useTimestamps && (this.output += this.formatDate() + " "), this.output += e.map(function(e2) {
      return t2.stringify(e2);
    }).join(" "), this.output += "\n", this.autoTrim && (this.output = this.trimLog(this.maxLines)), this.useLocalStorage) {
      var i = { startTime: this.startTime, log: this.output, lastLog: new Date() };
      window.localStorage.setItem(this.localStorageKey, JSON.stringify(i));
    }
  }, t.prototype.logMetadata = function(t2) {
    this.includeSessionMetadata && (this.output += "---- " + t2 + " ----\n");
  }, t.prototype.log = function() {
    for (var t2 = [], e = 0; e < arguments.length; e++)
      t2[e] = arguments[e];
    this.realTimeLoggingOn && console.log.apply(console, t2), this.recordLogs && this.recordLog.apply(this, t2);
  }, t.prototype.info = function() {
    for (var t2 = [], e = 0; e < arguments.length; e++)
      t2[e] = arguments[e];
    this.realTimeLoggingOn && console.info.apply(console, t2), this.recordLogs && (this.output += "[INFO] ", this.recordLog.apply(this, t2));
  }, t.prototype.warn = function() {
    for (var t2 = [], e = 0; e < arguments.length; e++)
      t2[e] = arguments[e];
    this.realTimeLoggingOn && console.warn.apply(console, t2), this.recordLogs && (this.output += "[WARN] ", this.recordLog.apply(this, t2));
  }, t.prototype.error = function() {
    for (var t2 = [], e = 0; e < arguments.length; e++)
      t2[e] = arguments[e];
    this.realTimeLoggingOn && console.error.apply(console, t2), this.recordLogs && (this.output += "[ERROR] ", this.recordLog.apply(this, t2));
  }, t.prototype.debug = function() {
    for (var t2 = [], e = 0; e < arguments.length; e++)
      t2[e] = arguments[e];
    this.realTimeLoggingOn && console.debug.apply(console, t2), this.recordLogs && (this.output += "[DEBUG] ", this.recordLog.apply(this, t2));
  }, t.prototype.getLog = function() {
    var t2 = new Date();
    if (this.recordLogs || this.info("Log recording is off"), this.useLocalStorage && window && window.localStorage) {
      var e = this.load();
      e && (this.startTime = new Date(e.startTime), this.output = e.log);
    }
    return this.includeSessionMetadata ? this.output + "---- " + this.formatSessionDuration(this.startTime, t2) + " ----\n" : this.output;
  }, t.prototype.clear = function() {
    this.output = "", this.logMetadata("Session started: " + this.formatDate(this.startTime)), this.logMetadata("Log cleared " + this.formatDate()), this.useLocalStorage && this.save();
  }, t.prototype.tail = function(t2) {
    var e = t2 || this.tailNumLines;
    return this.trimLog(e);
  }, t.prototype.search = function(t2) {
    for (var e = new RegExp(t2, "ig"), o = this.output.split("\n"), i = [], r = 0; r < o.length; r++) {
      var n = "[" + r + "] ";
      o[r].match(e) && i.push(n + o[r].trim());
    }
    var s = i.join("\n");
    return s.length || (s = 'Nothing found for "' + t2 + '".'), s;
  }, t.prototype.slice = function() {
    for (var t2, e = [], o = 0; o < arguments.length; o++)
      e[o] = arguments[o];
    return (t2 = this.output.split("\n")).slice.apply(t2, e).join("\n");
  }, t.prototype.downloadLog = function() {
    if (window) {
      var t2 = this.getLog(), e = new Blob([t2], { type: "data:text/plain;charset=utf-8" }), o = document.createElement("a");
      o.href = window.URL.createObjectURL(e), o.target = "_blank", o.download = this.logFilename, document.body.appendChild(o), o.click(), document.body.removeChild(o), window.URL.revokeObjectURL(o.href);
    } else
      console.error("downloadLog only works in the browser");
  }, t.prototype.save = function() {
    var t2 = { startTime: this.startTime, log: this.output, lastLog: new Date() };
    window.localStorage.setItem(this.localStorageKey, JSON.stringify(t2));
  }, t.prototype.load = function() {
    var t2 = window.localStorage.getItem(this.localStorageKey);
    return t2 ? JSON.parse(t2) : null;
  }, t.prototype.determineType = function(e) {
    if (e === null)
      return "null";
    if (e === void 0)
      return "undefined";
    var o = typeof e;
    return o === "object" && (o = Array.isArray(e) ? "Array" : e instanceof Date ? "Date" : e instanceof RegExp ? "RegExp" : e instanceof t ? "Debugout" : "Object"), o;
  }, t.prototype.stringifyObject = function(t2, e) {
    e === void 0 && (e = 0);
    var o = "{", i = e;
    if (this.objectSize(t2) > 0) {
      o += "\n", i++;
      var r = 0;
      for (var n in t2) {
        o += this.indentsForDepth(i), o += n + ": ";
        var s = this.stringify(t2[n], i);
        s && (o += s), r < this.objectSize(t2) - 1 && (o += ","), o += "\n", r++;
      }
      i--, o += this.indentsForDepth(i);
    }
    return o += "}";
  }, t.prototype.stringifyArray = function(t2, e) {
    e === void 0 && (e = 0);
    var o = "[", i = e, r = false;
    if (t2.length > 0) {
      i++;
      for (var n = 0; n < t2.length; n++) {
        var s = this.determineType(t2[n]), a = false;
        s === "Object" && this.objectSize(t2[n]) > 0 && (a = true), s === "Array" && t2[n].length > 0 && (a = true), !r && a && (o += "\n");
        var u = this.stringify(t2[n], i);
        u && (a && (o += this.indentsForDepth(i)), o += u, n < t2.length - 1 && (o += ", "), a && (o += "\n")), r = a;
      }
      i--;
    }
    return o += "]";
  }, t.prototype.stringifyFunction = function(t2, e) {
    var o = this;
    e === void 0 && (e = 0);
    var i = e;
    return String(t2).split("\n").map(function(t3) {
      t3.match(/\}/) && i--;
      var e2 = o.indentsForDepth(i) + t3.trim();
      return t3.match(/\{/) && i++, e2;
    }).join("\n");
  }, t.prototype.stringify = function(t2, e) {
    if (e === void 0 && (e = 0), e >= this.maxDepth)
      return "... (max-depth reached)";
    var o = this.determineType(t2);
    switch (o) {
      case "Object":
        return this.stringifyObject(t2, e);
      case "Array":
        return this.stringifyArray(t2, e);
      case "function":
        return this.stringifyFunction(t2, e);
      case "RegExp":
        return "/" + t2.source + "/" + t2.flags;
      case "Date":
      case "string":
        return this.quoteStrings ? '"' + t2 + '"' : t2 + "";
      case "boolean":
        return t2 ? "true" : "false";
      case "number":
        return t2 + "";
      case "null":
      case "undefined":
        return o;
      case "Debugout":
        return "... (Debugout)";
      default:
        return "?";
    }
  }, t.prototype.trimLog = function(t2) {
    var e = this.output.split("\n");
    return e.pop(), e.length > t2 && (e = e.slice(e.length - t2)), e.join("\n") + "\n";
  }, t.prototype.formatSessionDuration = function(t2, e) {
    var o = e - t2, i = Math.floor(o / 1e3 / 60 / 60), r = ("0" + i).slice(-2);
    o -= 1e3 * i * 60 * 60;
    var n = Math.floor(o / 1e3 / 60), s = ("0" + n).slice(-2);
    o -= 1e3 * n * 60;
    var a = Math.floor(o / 1e3);
    return o -= 1e3 * a, "Session duration: " + r + ":" + s + ":" + ("0" + a).slice(-2);
  }, t.prototype.formatDate = function(t2) {
    return t2 === void 0 && (t2 = new Date()), "[" + t2.toISOString() + "]";
  }, t.prototype.objectSize = function(t2) {
    var e = 0;
    for (var o in t2)
      t2.hasOwnProperty(o) && e++;
    return e;
  }, t;
}();

// src/main.ts
var import_obsidian6 = __toModule(require("obsidian"));
var import_path2 = __toModule(require("path"));

// src/constants.ts
var templatePlain = "# {{title}}\n\n## Metadata\n- **CiteKey**: {{citekey}}\n - **Type**: {{itemType}}\n - **Title**: {{title}}, \n - **Author**: {{author}};  \n- **Editor**: {{editor}};  \n- **Translator**: {{translator}}\n- **Publisher**: {{publisher}},\n- **Location**: {{place}},\n- **Series**: {{series}}\n- **Series Number**: {{seriesNumber}}\n- **Journal**: {{publicationTitle}}, \n- **Volume**: {{volume}},\n- **Issue**: {{issue}}\n- **Pages**: {{pages}}\n- **Year**: {{year}} \n- **DOI**: {{DOI}}\n- **ISSN**: {{ISSN}}\n- **ISBN**: {{ISBN}}\n\n## Abstract\n{{abstractNote}}\n## Files and Links\n- **Url**: {{url}}\n- **Uri**: {{uri}}\n- **Eprint**: {{eprint}}\n- **File**: {{file}}\n- **Local Library**: [Zotero]({{localLibraryLink}})\n\n## Tags and Collections\n- **Keywords**: {{keywordsAll}}\n- **Collections**: {{collectionsParent}}\n\n\n----\n\n## Comments\n{{UserNotes}}\n\n\n----\n\n## Extracted Annotations\n{{PDFNotes}}";
var templateAdmonition = "# {{title}}\n\n``` ad-info\ntitle: Metadata\n- **CiteKey**: {{citekey}}\n- **Type**: {{itemType}}\n- **Author**: {{author}}\n- **Editor**: {{editor}}\n- **Translator**: {{translator}}\n- **Publisher**: {{publisher}}\n- **Location**: {{place}}\n- **Series**: {{series}}\n- **Series Number**: {{seriesNumber}}\n- **Journal**: {{publicationTitle}}\n- **Volume**: {{volume}}\n- **Issue**: {{issue}}\n- **Pages**: {{pages}}\n- **Year**: {{year}} \n- **DOI**: {{DOI}}\n- **ISSN**: {{ISSN}}\n- **ISBN**: {{ISBN}}\n```\n```ad-quote\ntitle: Abstract\n{{abstractNote}}\n```\n```ad-abstract\ntitle: Files and Links\n- **Url**: {{url}}\n- **Uri**: {{uri}}\n- **Eprint**: {{eprint}}\n- **File**: {{file}}\n- **Local Library**: [Zotero]({{localLibraryLink}})\n```\n```ad-note\ntitle: Tags and Collections\n- **Keywords**: {{keywordsAll}}\n- **Collections**: {{collectionsParent}}\n```\n\n----\n\n## Comments\n{{UserNotes}}\n\n\n----\n\n## Extracted Annotations\n{{PDFNotes}}";
var DEFAULT_SETTINGS = {
  bibPath: "",
  templateContent: templatePlain,
  templatePath: "",
  templateType: "Admonition",
  lastUpdateDate: new Date("1995-12-17T03:24:00"),
  updateLibrary: "Only update existing notes",
  exportPath: "",
  exportTitle: "{{citeKey}}",
  missingfield: "Leave placeholder",
  saveManualEdits: "Save Entire Note",
  saveManualEditsStart: "",
  saveManualEditsEnd: "",
  imagesImport: true,
  imagesCopy: false,
  imagesPath: "",
  imagesCommentPosition: "Above the image",
  keyMergeAbove: "+",
  keyCommentPrepend: "%",
  commentPrependDefault: false,
  commentPrependDivider: ": ",
  keyH1: "#",
  keyH2: "##",
  keyH3: "###",
  keyH4: "####",
  keyH5: "#####",
  keyH6: "######",
  keyKeyword: "=",
  keyTask: "todo",
  isHighlightItalic: true,
  isHighlightBold: false,
  isHighlightHighlighted: false,
  isHighlightBullet: true,
  isHighlightBlockquote: false,
  isHighlightQuote: true,
  isCommentItalic: false,
  isCommentBold: true,
  isCommentHighlighted: false,
  isCommentBullet: false,
  isCommentBlockquote: true,
  isCommentQuote: false,
  isDoubleSpaced: true,
  highlightCustomTextBefore: "",
  highlightCustomTextAfter: "",
  commentCustomTextBefore: "",
  commentCustomTextAfter: "",
  colourYellowText: "{{highlight}}",
  colourPurpleText: "{{highlight}}",
  colourRedText: "{{highlight}}",
  colourGreenText: "{{highlight}}",
  colourBlueText: "{{highlight}}",
  colourBlackText: "{{highlight}}",
  colourWhiteText: "{{highlight}}",
  colourGrayText: "{{highlight}}",
  colourOrangeText: "{{highlight}}",
  colourCyanText: "{{highlight}}",
  colourMagentaText: "{{highlight}}",
  multipleFieldsDivider: ";",
  nameFormat: "{{lastName}}, {{firstName}}",
  highlightCitationsFormat: "Author, year, page number",
  highlightCitationsLink: true,
  debugMode: false,
  zoteroStoragePathManual: "",
  missingfieldreplacement: "NA"
};
var HeaderLevels;
(function(HeaderLevels2) {
  HeaderLevels2[HeaderLevels2["typeH1"] = 1] = "typeH1";
  HeaderLevels2[HeaderLevels2["typeH2"] = 2] = "typeH2";
  HeaderLevels2[HeaderLevels2["typeH3"] = 3] = "typeH3";
  HeaderLevels2[HeaderLevels2["typeH4"] = 4] = "typeH4";
  HeaderLevels2[HeaderLevels2["typeH5"] = 5] = "typeH5";
  HeaderLevels2[HeaderLevels2["typeH6"] = 6] = "typeH6";
})(HeaderLevels || (HeaderLevels = {}));
var TEMPLATE_REG = /\{\{[^}]+\}\}/g;
var TEMPLATE_BRACKET_REG = /\[\[\{\{[^}]+\}\}\]\]/g;

// src/modal.ts
var fs = __toModule(require("fs"));
var import_obsidian2 = __toModule(require("obsidian"));

// src/utils.ts
var import_obsidian = __toModule(require("obsidian"));
var import_path = __toModule(require("path"));
function replaceAllTemplates(entriesArray, note, selectedEntry) {
  let copy = note.slice();
  for (let z = 0; z < entriesArray.length; z++) {
    const KW = entriesArray[z];
    const KW_Brackets = "{{" + KW + "}}";
    copy = replaceTemplate(copy, KW_Brackets, `${selectedEntry[KW]}`);
  }
  return copy;
}
function escapeRegExp(stringAdd) {
  return stringAdd.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function replaceTemplate(stringAdd, find, replace) {
  return stringAdd.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
var makeWiki = (str) => "[[" + str + "]]";
var makeQuotes = (str) => '"' + str + '"';
var makeTags = (str) => "#" + str;
var createAuthorKey = (creators) => {
  const authorKey = [];
  let authorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (creator.creatorType === "author") {
      if (creator.hasOwnProperty("name")) {
        authorKey.push(creator.name);
      } else if (creator.hasOwnProperty("lastName") && creator.hasOwnProperty("firstName")) {
        authorKey.push(creator.lastName);
      } else if (creator.hasOwnProperty("lastName") && !creator.hasOwnProperty("firstName")) {
        authorKey.push(creator.lastName);
      } else if (!creator.hasOwnProperty("lastName") && creator.hasOwnProperty("firstName")) {
        authorKey.push(creator.firstName);
      }
    } else if (creator.creatorType === "editor") {
      if (creator.hasOwnProperty("name")) {
        authorKey.push(creator.name);
      } else if (creator.hasOwnProperty("lastName") && creator.hasOwnProperty("firstName")) {
        authorKey.push(creator.lastName);
      } else if (creator.hasOwnProperty("lastName") && !creator.hasOwnProperty("firstName")) {
        authorKey.push(creator.lastName);
      } else if (!creator.hasOwnProperty("lastName") && creator.hasOwnProperty("firstName")) {
        authorKey.push(creator.firstName);
      }
    }
  }
  if (authorKey.length == 1) {
    authorKeyFixed = authorKey[0];
  }
  if (authorKey.length == 2) {
    authorKeyFixed = authorKey[0] + " and " + authorKey[1];
  }
  if (authorKey.length > 2) {
    authorKeyFixed = authorKey[0] + " et al.";
  }
  return authorKeyFixed;
};
function removeQuoteFromStart(quote, annotation) {
  let copy = annotation.slice();
  while (copy.charAt(0) === quote)
    copy = copy.substring(1);
  return copy;
}
function removeQuoteFromEnd(quote, annotation) {
  let copy = annotation.slice();
  while (copy[copy.length - 1] === quote)
    copy = copy.substring(0, copy.length - 1);
  return copy;
}
function orderByDateModified(a, b) {
  if (a.dateModified > b.dateModified) {
    return -1;
  }
  if (a.dateModified < b.dateModified) {
    return 1;
  }
  return 0;
}
function formatCreatorsName(creator, nameCustom) {
  if (creator.hasOwnProperty("name")) {
    nameCustom = creator.name;
    nameCustom = nameCustom.trim();
    return nameCustom;
  } else if (creator.hasOwnProperty("lastName") && creator.hasOwnProperty("firstName")) {
    nameCustom = nameCustom.replace("{{lastName}}", creator.lastName);
    nameCustom = nameCustom.replace("{{firstName}}", creator.firstName);
    nameCustom = nameCustom.trim();
    return nameCustom;
  } else if (creator.hasOwnProperty("lastName") && !creator.hasOwnProperty("firstName")) {
    nameCustom = nameCustom.replace("{{lastName}}", creator.lastName);
    nameCustom = nameCustom.replace("; {{firstName}}", creator.firstName);
    nameCustom = nameCustom.replace(", {{firstName}}", creator.firstName);
    nameCustom = nameCustom.replace("{{firstName}}", "");
    nameCustom = nameCustom.trim();
    return nameCustom;
  } else if (!creator.hasOwnProperty("lastName") && creator.hasOwnProperty("firstName")) {
    nameCustom = nameCustom.replace("; {{lastName}}", creator.firstName);
    nameCustom = nameCustom.replace(", {{lastName}}", creator.firstName);
    nameCustom = nameCustom.replace("{{lastName}}", "");
    nameCustom = nameCustom.replace("{{firstName}}", creator.firstName);
    nameCustom = nameCustom.trim();
    return nameCustom;
  }
}
var createCreatorList = (creators, typeCreator, note, divider, nameFormat) => {
  const creatorList = [];
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (creator.creatorType === typeCreator) {
      creatorList.push(formatCreatorsName(creator, nameFormat));
    }
  }
  const creatorListBracket = creatorList.map(makeWiki);
  const creatorListQuotes = creatorList.map(makeQuotes);
  if (divider.slice(-1) !== " ") {
    divider = divider + " ";
  }
  if (creatorList.length == 0) {
    return note;
  } else {
    note = replaceTemplate(note, `[[{{${typeCreator}}}]]`, creatorListBracket.join(divider));
    note = replaceTemplate(note, `"{{${typeCreator}}}"`, creatorListQuotes.join(divider));
    note = replaceTemplate(note, `{{${typeCreator}}}`, creatorList.join(divider));
    return note;
  }
};
var createCreatorAllList = (creators, note, divider, nameFormat) => {
  const creatorList = [];
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    creatorList.push(formatCreatorsName(creator, nameFormat));
  }
  const creatorListBracket = creatorList.map(makeWiki);
  const creatorListQuotes = creatorList.map(makeQuotes);
  if (divider.slice(-1) !== " ") {
    divider = divider + " ";
  }
  if (creatorList.length == 0) {
    return note;
  } else {
    note = replaceTemplate(note, `[[{{creator}}]]`, creatorListBracket.join(divider));
    note = replaceTemplate(note, `"{{creator}}"`, creatorListQuotes.join(divider));
    note = replaceTemplate(note, `{{creator}}`, creatorList.join(divider));
    note = replaceTemplate(note, `{{Creator}}`, creatorList.join(divider));
    return note;
  }
};
function replaceMissingFields(note, missingfield, missingfieldreplacement) {
  let copy = note.slice();
  if (missingfield === "Replace with custom text") {
    copy = copy.replace(TEMPLATE_BRACKET_REG, missingfieldreplacement).trim();
    copy = copy.replace(TEMPLATE_REG, missingfieldreplacement).trim();
  } else if (missingfield === "Remove (entire row)") {
    const lines = copy.split(/\r?\n/);
    for (let j = 0; j < lines.length; j++) {
      if (lines[j].match(TEMPLATE_REG)) {
        lines.splice(j, 1);
        j--;
      }
    }
    copy = lines.join("\n");
  }
  copy = copy.replace("```ad-quote\ntitle: Abstract\n```\n", "");
  copy = copy.replace("```ad-abstract\ntitle: Files and Links\n```\n", "");
  copy = copy.replace("```ad-note\ntitle: Tags and Collections\n```\n", "");
  copy = copy.replace("## Abstract\n\n## Files and Links\n", "## Files and Links\n");
  copy = copy.replace("## Files and Links\n\n## Tags and Collections\n", "## Tags and Collections\n");
  copy = copy.replace("## Tags and Collections\n\n", "\n");
  return copy;
}
function createLocalFileLink(reference2) {
  if (reference2.attachments.length == 0)
    return "{{localFile}}";
  const filesList = [];
  for (let attachmentindex = 0; attachmentindex < reference2.attachments.length; attachmentindex++) {
    if (reference2.attachments[attachmentindex].itemType !== "attachment")
      continue;
    // if (reference2.attachments[attachmentindex].path == void 0) {
    //   reference2.attachments[attachmentindex].path = "";
    // }
    // const attachmentPathCorrected = reference2.attachments[attachmentindex].path.replaceAll(" ", "%20");
    // const selectedfile = "[" + reference2.attachments[attachmentindex].title + "](file://" + attachmentPathCorrected + ")";
    if (reference2.attachments[attachmentindex].uri == void 0) {
      reference2.attachments[attachmentindex].uri = "";
    }
    const selectedfileUri = reference2.attachments[attachmentindex].uri
    const attachmentKey = selectedfileUri.split('/')[selectedfileUri.split('/').length - 1]
    selectedfile = "[" + reference2.attachments[attachmentindex].title + "](zotero://select/library/items/" + attachmentKey + ")";
    if (reference2.attachments[attachmentindex].title.endsWith('pdf')) {
      selectedfile = selectedfile.replaceAll("zotero://select/","zotero://open-pdf/");
    }
    filesList.push(selectedfile);
  }
  const filesListString = filesList.join("; ");
  return filesListString;
}
// function createLocalFileLink(reference2) {
//   if (reference2.attachments.length == 0)
//     return "{{localFile}}";
//   const filesList = [];
//   for (let attachmentindex = 0; attachmentindex < reference2.attachments.length; attachmentindex++) {
//     if (reference2.attachments[attachmentindex].itemType !== "attachment")
//       continue;
//     if (reference2.attachments[attachmentindex].path == void 0) {
//       reference2.attachments[attachmentindex].path = "";
//     }
//     const attachmentPathCorrected = reference2.attachments[attachmentindex].path.replaceAll(" ", "%20");
//     const selectedfile = "[" + reference2.attachments[attachmentindex].title + "](file://" + attachmentPathCorrected + ")";
//     filesList.push(selectedfile);
//   }
//   const filesListString = filesList.join("; ");
//   return filesListString;
// }
function createNoteTitle(selectedEntry, exportTitle, exportPath) {
  exportTitle = exportTitle.replace("{{citeKey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citationKey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citationkey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citekey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{title}}", selectedEntry.title);
  exportTitle = exportTitle.replace("{{author}}", selectedEntry.authorKey);
  exportTitle = exportTitle.replace("{{authors}}", selectedEntry.authorKey);
  exportTitle = exportTitle.replace("{{year}}", selectedEntry.year);
  exportTitle = exportTitle.replace("{{date}}", selectedEntry.year);
  exportTitle = exportTitle.replace(/[/\\?%*:|"<>]/g, "");
  const vaultPath = this.app.vault.adapter.getBasePath();
  const exportPathFull = import_path.default.normalize(vaultPath + "/" + exportPath + "/" + exportTitle + ".md");
  return exportPathFull;
}
function replaceTagList(selectedEntry, arrayExtractedKeywords, metadata, divider) {
  selectedEntry.zoteroTags = [];
  if (selectedEntry.tags.length > 0) {
    for (let indexTag = 0; indexTag < selectedEntry.tags.length; indexTag++) {
      selectedEntry.zoteroTags.push(selectedEntry.tags[indexTag].tag);
    }
  }
  if (divider.slice(-1) !== " ") {
    divider = divider + " ";
  }
  const tagsZotero = selectedEntry.zoteroTags.sort();
  const tagsPDF = arrayExtractedKeywords.sort();
  const tagsCombined = tagsZotero.concat(tagsPDF).sort();
  if (tagsZotero.length > 0) {
    const tagsZoteroBracket = tagsZotero.map(makeWiki);
    metadata = replaceTemplate(metadata, `[[{{keywordsZotero}}]]`, String(tagsZoteroBracket.join(divider)));
    const tagsZoteroQuotes = tagsZotero.map(makeQuotes);
    metadata = replaceTemplate(metadata, `"{{keywordsZotero}}"`, String(tagsZoteroQuotes.join(divider)));
    const tagsZoteroTags = tagsZotero.map(makeTags);
    metadata = replaceTemplate(metadata, `#{{keywordsZotero}}`, String(tagsZoteroTags.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywordsZotero}}`, String(tagsZotero.join(divider)));
  }
  if (tagsPDF.length > 0) {
    const tagsPDFBracket = tagsPDF.map(makeWiki);
    metadata = replaceTemplate(metadata, `[[{{keywordsPDF}}]]`, String(tagsPDFBracket.join(divider)));
    const tagsPDFQuotes = tagsPDF.map(makeQuotes);
    metadata = replaceTemplate(metadata, `"{{keywordsPDF}}"`, String(tagsPDFQuotes.join(divider)));
    const tagsPDFTags = tagsPDF.map(makeTags);
    metadata = replaceTemplate(metadata, `#{{keywordsPDF}}`, String(tagsPDFTags.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywordsPDF}}`, String(tagsPDF.join(divider)));
  }
  if (tagsCombined.length > 0) {
    const tagsCombinedBracket = tagsCombined.map(makeWiki);
    metadata = replaceTemplate(metadata, `[[{{keywords}}]]`, String(tagsCombinedBracket.join(divider)));
    metadata = replaceTemplate(metadata, `[[{{keywordsAll}}]]`, String(tagsCombinedBracket.join(divider)));
    const tagsCombinedQuotes = tagsCombined.map(makeQuotes);
    metadata = replaceTemplate(metadata, `"{{keywordsAll}}"`, String(tagsCombinedQuotes.join(divider)));
    metadata = replaceTemplate(metadata, `"{{keywords}}"`, String(tagsCombinedQuotes.join(divider)));
    const tagsCombinedTags = tagsCombined.map(makeTags);
    metadata = replaceTemplate(metadata, `#{{keywordsAll}}`, String(tagsCombinedTags.join(divider)));
    metadata = replaceTemplate(metadata, `#{{keywords}}`, String(tagsCombinedTags.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywordsAll}}`, String(tagsCombined.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywords}}`, String(tagsCombined.join(divider)));
  }
  if (selectedEntry.zoteroTags.length == 0) {
    metadata = metadata.replace("# Tags\n", "");
    metadata = metadata.replace("## Tags\n", "");
    metadata = metadata.replace("### Tags\n", "");
  }
  return metadata;
}
function openSelectedNote(selectedEntry, exportTitle, exportPath) {
  const noteTitleFull = createNoteTitle(selectedEntry, exportTitle, exportPath);
  const noteTitleShort = noteTitleFull.replace((0, import_obsidian.normalizePath)(this.app.vault.adapter.getBasePath()) + "/", "");
  const myFile = this.app.vault.getAbstractFileByPath(noteTitleShort);
  this.app.workspace.getUnpinnedLeaf().openFile(myFile);
}

// src/modal.ts
var fuzzySelectEntryFromJson = class extends import_obsidian2.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  focusInput() {
    document.getElementsByClassName("prompt-input")[0].focus();
  }
  onOpen() {
    return __async(this, null, function* () {
      if (import_obsidian2.Platform.isDesktopApp) {
        this.focusInput();
      }
      const rawdata = fs.readFileSync(this.app.vault.adapter.getBasePath() + "/" + this.plugin.settings.bibPath);
      const data = JSON.parse(rawdata.toString());
      const bibtexArray = [];
      for (let index = 0; index < data.items.length; index++) {
        const selectedEntry = data.items[index];
        const bibtexArrayItem = {};
        if (selectedEntry.hasOwnProperty("citationKey") == false)
          continue;
        bibtexArrayItem.citationKey = selectedEntry.citationKey;
        bibtexArrayItem.title = selectedEntry.title;
        bibtexArrayItem.date = selectedEntry.date;
        if (selectedEntry.hasOwnProperty("date")) {
          selectedEntry.year = selectedEntry.date.match(/\d\d\d\d/gm);
          bibtexArrayItem.date = selectedEntry.year;
        }
        bibtexArrayItem.authorKey = createAuthorKey(selectedEntry.creators);
        bibtexArrayItem.dateModified = selectedEntry.dateModified;
        bibtexArrayItem.inlineReference = bibtexArrayItem.authorKey + ", (" + bibtexArrayItem.date + "), '" + bibtexArrayItem.title + "'\n" + bibtexArrayItem.citationKey;
        bibtexArray.push(bibtexArrayItem);
      }
      bibtexArray.sort(orderByDateModified);
      this.allCitationKeys = bibtexArray.map((a) => a.citationKey);
      const selectLibrary = {
        inlineReference: "Entire Library: " + this.plugin.settings.bibPath,
        citationKey: "Entire Library",
        authorKey: "",
        id: 0,
        year: "",
        itemType: "",
        date: "",
        dateModified: "",
        itemKey: "",
        title: "",
        creators: [],
        itemID: 0,
        file: "",
        localLibrary: "",
        select: "",
        attachments: [],
        notes: [],
        tags: [],
        zoteroTags: []
      };
      bibtexArray.unshift(selectLibrary);
      this.selectArray = bibtexArray;
      yield this.updateSuggestions();
      this.data = data;
    });
  }
  getItems() {
    return this.selectArray;
  }
  getItemText(referenceSelected) {
    return referenceSelected.inlineReference;
  }
  updateSuggestions() {
    var __superGet = (key) => super[key];
    return __async(this, null, function* () {
      yield __superGet("updateSuggestions").call(this);
    });
  }
  onChooseItem(referenceSelected, evt) {
    return __async(this, null, function* () {
      let citeKeyToBeProcessed = [];
      if (referenceSelected.citationKey === "Entire Library") {
        console.log("all library selected");
        citeKeyToBeProcessed = citeKeyToBeProcessed.concat(this.allCitationKeys);
      } else {
        citeKeyToBeProcessed.push(referenceSelected.citationKey);
      }
      for (let indexNoteToBeProcessed = 0; indexNoteToBeProcessed < citeKeyToBeProcessed.length; indexNoteToBeProcessed++) {
        const indexSelectedReference = this.data.items.findIndex((item) => item.citationKey === citeKeyToBeProcessed[indexNoteToBeProcessed]);
        const selectedEntry = this.data.items[indexSelectedReference];
        this.plugin.createNote(selectedEntry, this.data);
        if (indexNoteToBeProcessed == citeKeyToBeProcessed.length - 1) {
          openSelectedNote(selectedEntry, this.plugin.settings.exportTitle, this.plugin.settings.exportPath);
        }
      }
    });
  }
};
var updateLibrary = class extends import_obsidian2.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    console.log("Updating Zotero library");
    const rawdata = fs.readFileSync(this.app.vault.adapter.getBasePath() + "/" + this.plugin.settings.bibPath);
    const data = JSON.parse(rawdata.toString());
    const bibtexArray = [];
    const lastUpdate = new Date(this.plugin.settings.lastUpdateDate);
    for (let index = 0; index < data.items.length; index++) {
      const selectedEntry = data.items[index];
      const bibtexArrayItem = {};
      if (selectedEntry.hasOwnProperty("citationKey") == false)
        continue;
      bibtexArrayItem.citationKey = selectedEntry.citationKey;
      const datemodified = new Date(selectedEntry.dateModified);
      if (datemodified < lastUpdate)
        continue;
      if (this.plugin.settings.updateLibrary === "Only update existing notes" && !fs.existsSync(createNoteTitle(selectedEntry, this.plugin.settings.exportTitle, this.plugin.settings.exportPath)))
        continue;
      this.plugin.createNote(selectedEntry, data);
      bibtexArray.push(selectedEntry.citationKey);
    }
    new import_obsidian2.Notice("Updated " + bibtexArray.length + " entries");
    this.plugin.settings.lastUpdateDate = new Date();
    this.plugin.saveSettings();
  }
  onClose() {
  }
};

// src/settings.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/suggesters/FolderSuggester.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/suggesters/suggest.ts
var import_obsidian3 = __toModule(require("obsidian"));

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on("click", ".suggestion-item", this.onSuggestionClick.bind(this));
    containerEl.on("mousemove", ".suggestion-item", this.onSuggestionMouseover.bind(this));
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(selectedIndex, this.suggestions.length);
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian3.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on("mousedown", ".suggestion-container", (event) => {
      event.preventDefault();
    });
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/suggesters/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian4.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings.ts
var SettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    containerEl.createEl("h1", { text: "BibNotes Formatter (for Zotero) " });
    containerEl.createEl("a", { text: "Created by Stefano Pagliari", href: "https://github.com/stefanopagliari/" });
    containerEl.createEl("h2", { text: "Import Library" });
    const importLibrary = containerEl.createEl("details");
    importLibrary.setAttribute("open", "");
    importLibrary.createEl("summary", { text: "" });
    new import_obsidian5.Setting(importLibrary).setName("Bibtex File").setDesc("Add Path to the *BetterBibTex Json* file to be imported").addText((text) => text.setPlaceholder("/path/to/BetterBibTex.json").setValue(settings.bibPath).onChange((value) => __async(this, null, function* () {
      console.log("Path Bib: " + value);
      settings.bibPath = value;
      yield plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Export Notes" });
    const settingsExport = containerEl.createEl("details");
    settingsExport.setAttribute("open", "");
    settingsExport.createEl("summary", { text: "" });
    new import_obsidian5.Setting(settingsExport).setName("Export Path").setDesc("Add the relative path to the folder inside your vault where the notes will be exported").addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder("Example: folder1/folder2").setValue(this.plugin.settings.exportPath).onChange((new_folder) => __async(this, null, function* () {
        settings.exportPath = new_folder;
        yield plugin.saveSettings();
      }));
    });
    new import_obsidian5.Setting(settingsExport).setName("Note Title").setDesc("Select the format of the title of the note. Possible values include: {{citeKey}}, {{title}}, {{author}}, {{year}}").addText((text) => text.setPlaceholder("{{citeKey}}").setValue(settings.exportTitle).onChange((value) => __async(this, null, function* () {
      settings.exportTitle = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsExport).setName("Select Template").setDesc("Select one of the default templates or provide a custom one.").addDropdown((d) => {
      d.addOption("Plain", "Plain");
      d.addOption("Admonition", "Admonition");
      d.addOption("Custom", "Custom Template");
      d.setValue(settings.templateType);
      d.onChange((v) => __async(this, null, function* () {
        settings.templateType = v;
        yield plugin.saveSettings();
        this.display();
      }));
    });
    if (settings.templateType === "Custom") {
      new import_obsidian5.Setting(settingsExport).setName("Custom Template").addTextArea((text) => {
        text.inputEl.rows = 10;
        text.inputEl.style.width = "100%";
        text.setValue(settings.templateContent).onChange((value) => __async(this, null, function* () {
          settings.templateContent = value;
          yield plugin.saveSettings();
        }));
      });
    }
    new import_obsidian5.Setting(settingsExport).setName("Missing Fields").setDesc("Fields that are present in the template but missing from the selected field.").addDropdown((d) => {
      d.addOption("Leave placeholder", "Leave placeholder");
      d.addOption("Remove (entire row)", "Remove (entire row)");
      d.addOption("Replace with custom text", "Replace with custom text");
      d.setValue(settings.missingfield);
      d.onChange((v) => __async(this, null, function* () {
        settings.missingfield = v;
        yield plugin.saveSettings();
        this.display();
      }));
    });
    if (settings.missingfield === "Replace with custom text") {
      new import_obsidian5.Setting(settingsExport).setName("Replacement for missing fields").addText((text) => text.setValue(settings.missingfieldreplacement).onChange((value) => __async(this, null, function* () {
        settings.missingfieldreplacement = value;
        yield plugin.saveSettings();
      })));
    }
    new import_obsidian5.Setting(settingsExport).setName("Multiple Entries Divider").setDesc("Type the character or expression that should separate multiple values when found in the same field (e.g. authors, editors, tags, collections).").addTextArea((text) => text.setValue(settings.multipleFieldsDivider).onChange((value) => __async(this, null, function* () {
      settings.multipleFieldsDivider = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsExport).setName("Format Names").setDesc("Specify how the names of the authors/editors should be exported.").addTextArea((text) => text.setValue(settings.nameFormat).onChange((value) => __async(this, null, function* () {
      settings.nameFormat = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsExport).setName("Save Manual Edits").setDesc('Select "Yes" to preserve the manual edits made to the previously extracted note (e.g. block references, comments added manually, fixed typos) when this is updated. Select "No" to overwrite any manual change to the extracted annotation when this is updated.').addDropdown((d) => {
      d.addOption("Save Entire Note", "Save Entire Note");
      d.addOption("Select Section", "Select Section");
      d.addOption("Overwrite Entire Note", "Overwrite Entire Note");
      d.setValue(settings.saveManualEdits);
      d.onChange((v) => __async(this, null, function* () {
        settings.saveManualEdits = v;
        yield plugin.saveSettings();
        this.display();
      }));
    });
    if (settings.saveManualEdits == "Select Section") {
      new import_obsidian5.Setting(settingsExport).setName("Start - Save Manual Edits").setDesc("Define string (e.g. '## Notes') in the template starting from where updating the note will not overwrite the existing text. If field is left empty, the value will be set to the beginning of the note").addText((text) => text.setValue(settings.saveManualEditsStart).onChange((value) => __async(this, null, function* () {
        settings.saveManualEditsStart = value;
        yield plugin.saveSettings();
      })));
      if (settings.saveManualEdits) {
        new import_obsidian5.Setting(settingsExport).setName("End - Save Manual Edits").setDesc("Define string (e.g. '## Notes') in the template until where updating the note will not overwrite the existing text. If field is left empty, the value will be set to the end of the note").addText((text) => text.setValue(settings.saveManualEditsEnd).onChange((value) => __async(this, null, function* () {
          settings.saveManualEditsEnd = value;
          yield plugin.saveSettings();
        })));
      }
    }
    containerEl.createEl("h2", { text: "Update Library" });
    const settingsUpdate = containerEl.createEl("details");
    settingsUpdate.setAttribute("open", "");
    new import_obsidian5.Setting(settingsUpdate).setName("Update Existing/All Notes").setDesc("Select whether to create new notes that are missing from Obsidian but present/modified within Zotero when runing the Update Library command").addDropdown((d) => {
      d.addOption("Only update existing notes", "Only existing notes");
      d.addOption("Create new notes when missing", "Create new notes when missing");
      d.setValue(settings.updateLibrary);
      d.onChange((v) => __async(this, null, function* () {
        settings.updateLibrary = v;
        yield plugin.saveSettings();
      }));
    });
    containerEl.createEl("h2", { text: "Format Annotations" });
    containerEl.createEl("h3", { text: "In-text citations" });
    const settingsCitations = containerEl.createEl("details");
    settingsCitations.setAttribute("open", "");
    settingsCitations.createEl("summary", { text: "" });
    new import_obsidian5.Setting(settingsCitations).setName("End of Highlight Citation Format").setDesc("Select the style of the reference added next to the highlights and figures extracted from the PDF. This feature is for now available only for sources extracted from Zotero").addDropdown((d) => {
      d.addOption("Author, year, page number", "Author, year, page number");
      d.addOption("Only page number", "Only page number");
      d.addOption("Pandoc", "Pandoc");
      d.addOption("Empty", "Empty");
      d.setValue(settings.highlightCitationsFormat);
      d.onChange((v) => __async(this, null, function* () {
        settings.highlightCitationsFormat = v;
        yield plugin.saveSettings();
      }));
    });
    new import_obsidian5.Setting(settingsCitations).setName("Create Link to the Highlight Page in the PDF").setDesc("If enabled, a link will be created at the end of the extracted highlights or figures to the original page of the PDF in the Zotero reader").addToggle((text) => text.setValue(settings.highlightCitationsLink).onChange((value) => __async(this, null, function* () {
      settings.highlightCitationsLink = value;
      yield plugin.saveSettings();
      this.display();
    })));
    containerEl.createEl("h3", { text: "Highlights" });
    const settingsHighlights = containerEl.createEl("details");
    settingsHighlights.setAttribute("open", "");
    settingsHighlights.createEl("summary", { text: "" });
    new import_obsidian5.Setting(settingsHighlights).setName("Double Spaced").setDesc("Set toggle to on to add an empty space between different highlights").addToggle((text) => text.setValue(settings.isDoubleSpaced).onChange((value) => __async(this, null, function* () {
      settings.isDoubleSpaced = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Quotation Marks").addToggle((text) => text.setValue(settings.isHighlightQuote).onChange((value) => __async(this, null, function* () {
      settings.isHighlightQuote = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Bold").addToggle((text) => text.setValue(settings.isHighlightBold).onChange((value) => __async(this, null, function* () {
      settings.isHighlightBold = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Italic").addToggle((text) => text.setValue(settings.isHighlightItalic).onChange((value) => __async(this, null, function* () {
      settings.isHighlightItalic = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Highlighted").addToggle((text) => text.setValue(settings.isHighlightHighlighted).onChange((value) => __async(this, null, function* () {
      settings.isHighlightHighlighted = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Bullet Points").addToggle((text) => text.setValue(settings.isHighlightBullet).onChange((value) => __async(this, null, function* () {
      settings.isHighlightBullet = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Blockquote").addToggle((text) => text.setValue(settings.isHighlightBlockquote).onChange((value) => __async(this, null, function* () {
      settings.isHighlightBlockquote = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Custom text before all highlights").addTextArea((text) => text.setValue(settings.highlightCustomTextBefore).onChange((value) => __async(this, null, function* () {
      console.log("highlightCustomTextBefore: " + value);
      settings.highlightCustomTextBefore = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsHighlights).setName("Custom text after all highlights").addTextArea((text) => text.setValue(settings.highlightCustomTextAfter).onChange((value) => __async(this, null, function* () {
      console.log("highlightCustomTextAfter: " + value);
      settings.highlightCustomTextAfter = value;
      yield plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Comments" });
    const settingsComments = containerEl.createEl("details");
    settingsComments.setAttribute("open", "");
    settingsComments.createEl("summary", { text: "" });
    new import_obsidian5.Setting(settingsComments).setName("Quotation Marks").addToggle((text) => text.setValue(settings.isCommentQuote).onChange((value) => __async(this, null, function* () {
      settings.isCommentQuote = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Bold").addToggle((text) => text.setValue(settings.isCommentBold).onChange((value) => __async(this, null, function* () {
      settings.isCommentBold = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Italic").addToggle((text) => text.setValue(settings.isCommentItalic).onChange((value) => __async(this, null, function* () {
      settings.isCommentItalic = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Highlighted").addToggle((text) => text.setValue(settings.isCommentHighlighted).onChange((value) => __async(this, null, function* () {
      settings.isCommentHighlighted = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Bullet Points").addToggle((text) => text.setValue(settings.isCommentBullet).onChange((value) => __async(this, null, function* () {
      settings.isCommentBullet = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Blockquote").addToggle((text) => text.setValue(settings.isCommentBlockquote).onChange((value) => __async(this, null, function* () {
      settings.isCommentBlockquote = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Custom text before all comments").addTextArea((text) => text.setValue(settings.commentCustomTextBefore).onChange((value) => __async(this, null, function* () {
      console.log("commentCustomTextBefore: " + value);
      settings.commentCustomTextBefore = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsComments).setName("Custom text after all comments").addTextArea((text) => text.setValue(settings.commentCustomTextAfter).onChange((value) => __async(this, null, function* () {
      console.log("commentCustomTextAfter: " + value);
      settings.commentCustomTextAfter = value;
      yield plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Additional Transformations" });
    const settingsAdvanced = containerEl.createEl("details");
    settingsAdvanced.setAttribute("open", "");
    settingsAdvanced.createEl("summary", { text: "" });
    new import_obsidian5.Setting(settingsAdvanced).setDesc("Add a single character (e.g. #) or a single word (e.g. todo). When this character/word is found at the beginning of a comment, the text of the comment or the highlighted text will be transformed");
    new import_obsidian5.Setting(settingsAdvanced).setName("Heading Level 1").addText((text) => text.setValue(settings.keyH1).onChange((value) => __async(this, null, function* () {
      console.log("H1: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyH1 = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Heading Level 2").addText((text) => text.setValue(settings.keyH2).onChange((value) => __async(this, null, function* () {
      console.log("H2: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyH2 = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Heading Level 3").addText((text) => text.setPlaceholder("###").setValue(settings.keyH3).onChange((value) => __async(this, null, function* () {
      console.log("H3: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyH3 = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Heading Level 4").addText((text) => text.setValue(settings.keyH4).onChange((value) => __async(this, null, function* () {
      console.log("H4: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyH4 = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Heading Level 5").addText((text) => text.setValue(settings.keyH5).onChange((value) => __async(this, null, function* () {
      console.log("H5: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyH5 = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Heading Level 6").addText((text) => text.setValue(settings.keyH6).onChange((value) => __async(this, null, function* () {
      console.log("H6: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyH6 = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Append highlight to the end of the previous one").addText((text) => text.setValue(settings.keyMergeAbove).onChange((value) => __async(this, null, function* () {
      console.log("MergeAbove: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyMergeAbove = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Place comment before the highlight").addText((text) => text.setValue(settings.keyCommentPrepend).onChange((value) => __async(this, null, function* () {
      console.log("CommentPrepend: " + value);
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyCommentPrepend = value;
        yield plugin.saveSettings();
      }
    })));
    new import_obsidian5.Setting(settingsAdvanced).setDesc("Text placed between the comment and the related highlight").addText((text) => text.setValue(settings.commentPrependDivider).onChange((value) => __async(this, null, function* () {
      settings.commentPrependDivider = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsAdvanced).setDesc("Always place the comment made to an highlight before the text of the highlight").addToggle((text) => text.setValue(settings.commentPrependDefault).onChange((value) => __async(this, null, function* () {
      settings.commentPrependDefault = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(settingsAdvanced).setName("Transform the highlight/comment into a task").addText((text) => text.setValue(settings.keyTask).onChange((value) => __async(this, null, function* () {
      if (Object.values(settings).indexOf(value) > -1) {
        alert("This value is already assigned to a different transformation. Chose a different value");
      } else {
        settings.keyTask = value;
        yield plugin.saveSettings();
      }
    })));
    containerEl.createEl("h3", { text: "Highlight Color" });
    const settingsColour = containerEl.createEl("details");
    settingsColour.setAttribute("open", "");
    settingsColour.createEl("summary", { text: "" });
    new import_obsidian5.Setting(settingsColour).setDesc('Select the transformation to be done to the highlights of different colour by adding one of the following options: {{highlight}} preceded or followed by custom text; "H1" (transform into Level 1 Header); "H2" (transform into Level 2 Header); "H3" (transform into Level 3 Header); "H4" (transform into Level 4 Header); "H5" (transform into Level 5 Header); "H6" (transform into Level 6 Header); "AddToAbove" (append the highlight to the previous one); "Keyword" (add the text to the list of keywords); "Todo" (transform the text of the highlight and associated comment into a task)');
    new import_obsidian5.Setting(settingsColour).setName("Yellow").setDesc("").addText((text) => text.setValue(settings.colourYellowText).onChange((value) => __async(this, null, function* () {
      settings.colourYellowText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Red").setDesc("").addText((text) => text.setValue(settings.colourRedText).onChange((value) => __async(this, null, function* () {
      settings.colourRedText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Green").setDesc("").addText((text) => text.setValue(settings.colourGreenText).onChange((value) => __async(this, null, function* () {
      settings.colourGreenText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Blue").setDesc("").addText((text) => text.setValue(settings.colourBlueText).onChange((value) => __async(this, null, function* () {
      settings.colourBlueText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Purple").setDesc("").addText((text) => text.setValue(settings.colourPurpleText).onChange((value) => __async(this, null, function* () {
      settings.colourPurpleText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Black").setDesc("").addText((text) => text.setValue(settings.colourBlackText).onChange((value) => __async(this, null, function* () {
      settings.colourBlackText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("White").setDesc("").addText((text) => text.setValue(settings.colourWhiteText).onChange((value) => __async(this, null, function* () {
      settings.colourWhiteText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Gray").setDesc("").addText((text) => text.setValue(settings.colourGrayText).onChange((value) => __async(this, null, function* () {
      settings.colourGrayText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Orange").setDesc("").addText((text) => text.setValue(settings.colourOrangeText).onChange((value) => __async(this, null, function* () {
      settings.colourOrangeText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Cyan").setDesc("").addText((text) => text.setValue(settings.colourCyanText).onChange((value) => __async(this, null, function* () {
      settings.colourCyanText = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian5.Setting(settingsColour).setName("Magenta").setDesc("").addText((text) => text.setValue(settings.colourMagentaText).onChange((value) => __async(this, null, function* () {
      settings.colourMagentaText = value;
      yield plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Import Images" });
    const importImages = containerEl.createEl("details");
    importImages.setAttribute("open", "");
    importImages.createEl("summary", { text: "" });
    new import_obsidian5.Setting(importImages).setName("Import Images").setDesc("This option is available only for notes extracted using the Zotero native PDF reader").addToggle((text) => text.setValue(settings.imagesImport).onChange((value) => __async(this, null, function* () {
      settings.imagesImport = value;
      yield plugin.saveSettings();
      this.display();
    })));
    new import_obsidian5.Setting(importImages).setName("Zotero Local Folder").setDesc(`Add the path on your computer where Zotero's data is stored (e.g. "/Users/yourusername/Zotero/storage"). This field is required only when this is different from the folder where the PDF files are stored. To retrieve this information, open Zotero --> Preferences --> Advanced --> Files and Folder, and copy the "data directory location"`).addText((text) => text.setValue(settings.zoteroStoragePathManual).onChange((value) => __async(this, null, function* () {
      settings.zoteroStoragePathManual = value;
      yield plugin.saveSettings();
    })));
    if (settings.imagesImport) {
      new import_obsidian5.Setting(importImages).setName("Copy the Image into the Obsidian Vault").setDesc("If this option is selected, images selected through the Zotero reader will be copied into the Vault. If this option is not selected, the note will link to the file stored in Zotero/storage").addToggle((text) => text.setValue(settings.imagesCopy).onChange((value) => __async(this, null, function* () {
        settings.imagesCopy = value;
        yield plugin.saveSettings();
        this.display();
      })));
      if (settings.imagesCopy) {
        new import_obsidian5.Setting(importImages).setName("Image Import Path").setDesc("Add the relative path to the folder inside your vault where the image will be copied").addSearch((cb) => {
          new FolderSuggest(this.app, cb.inputEl);
          cb.setPlaceholder("Example: folder1/folder2").setValue(this.plugin.settings.imagesPath).onChange((new_folder) => __async(this, null, function* () {
            settings.imagesPath = new_folder;
            yield plugin.saveSettings();
          }));
        });
      }
      new import_obsidian5.Setting(importImages).setName("Position of Comment to an Image").addDropdown((d) => {
        d.addOption("Above the image", "Above the image");
        d.addOption("Below the image", "Below the image");
        d.setValue(settings.imagesCommentPosition);
        d.onChange((v) => __async(this, null, function* () {
          settings.imagesCommentPosition = v;
          yield plugin.saveSettings();
          this.display();
        }));
      });
    }
    containerEl.createEl("h2", { text: "Debugging" });
    const debugSettings = containerEl.createEl("details");
    debugSettings.setAttribute("open", "");
    debugSettings.createEl("summary", { text: "" });
    new import_obsidian5.Setting(debugSettings).setName("Activate Debug Mode").setDesc("Activating this option will print the console logs of each entry exported in a text file to faciliate debugging.").addToggle((text) => text.setValue(settings.debugMode).onChange((value) => __async(this, null, function* () {
      settings.debugMode = value;
      yield plugin.saveSettings();
      this.display();
    })));
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian6.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new SettingTab(this.app, this));
      this.addCommand({
        id: "importSelectedJson-modal",
        name: "Create/Update Literature Note",
        callback: () => {
          new fuzzySelectEntryFromJson(this.app, this).open();
        }
      });
      this.addCommand({
        id: "updateLibrary-modal",
        name: "Update Library",
        callback: () => {
          new updateLibrary(this.app, this).open();
        }
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  createFormatting() {
    const {
      highlightCustomTextAfter,
      highlightCustomTextBefore,
      isCommentItalic,
      isCommentBold,
      isCommentHighlighted,
      isCommentBullet,
      isCommentBlockquote,
      isCommentQuote,
      commentCustomTextAfter,
      commentCustomTextBefore,
      isHighlightItalic,
      isHighlightBold,
      isHighlightHighlighted,
      isHighlightBullet,
      isHighlightBlockquote,
      isHighlightQuote
    } = this.settings;
    const [
      highlightItalic,
      highlightBold,
      highlightHighlighted,
      highlightBullet,
      highlightBlockquote,
      highlightQuoteOpen,
      highlightQuoteClose
    ] = [
      isHighlightItalic ? "*" : "",
      isHighlightBold ? "**" : "",
      isHighlightHighlighted ? "==" : "",
      isHighlightBullet ? "- " : "",
      isHighlightBlockquote ? "> " : "",
      isHighlightQuote ? "\u201C" : "",
      isHighlightQuote ? "\u201D" : ""
    ];
    const highlightFormatBefore = highlightHighlighted + highlightBold + highlightItalic + highlightQuoteOpen;
    const highlightFormatAfter = highlightQuoteClose + highlightItalic + highlightBold + highlightHighlighted + " " + highlightCustomTextAfter;
    const highlightPrepend = highlightBullet + highlightBlockquote + highlightCustomTextBefore;
    const commentItalic = isCommentItalic ? "*" : "";
    const commentBold = isCommentBold ? "**" : "";
    const commentHighlighted = isCommentHighlighted ? "==" : "";
    const commentBullet = isCommentBullet ? "- " : "";
    const commentBlockquote = isCommentBlockquote ? "> " : "";
    const commentQuoteOpen = isCommentQuote ? "\u201C" : "";
    const commentQuoteClose = isCommentQuote ? "\u201D" : "";
    const commentFormatBefore = commentHighlighted + commentBold + commentItalic + commentQuoteOpen;
    const commentFormatAfter = commentQuoteClose + commentItalic + commentBold + commentHighlighted + commentCustomTextAfter;
    const commentPrepend = commentBullet + commentBlockquote + " " + commentCustomTextBefore;
    return {
      highlightFormatBefore,
      highlightFormatAfter,
      highlightPrepend,
      commentFormatBefore,
      commentFormatAfter,
      commentPrepend
    };
  }
  parseMetadata(selectedEntry, templateOriginal) {
    const template = templateOriginal;
    let note = template;
    note = createCreatorList(selectedEntry.creators, "author", note, this.settings.multipleFieldsDivider, this.settings.nameFormat);
    note = createCreatorList(selectedEntry.creators, "editor", note, this.settings.multipleFieldsDivider, this.settings.nameFormat);
    note = createCreatorAllList(selectedEntry.creators, note, this.settings.multipleFieldsDivider, this.settings.nameFormat);
    if (selectedEntry.hasOwnProperty("date")) {
      selectedEntry.year = selectedEntry.date.match(/\d\d\d\d/gm) + "";
    }
    if (selectedEntry.hasOwnProperty("select")) {
      selectedEntry.localLibrary = "[Read it now! See in Zotero](" + selectedEntry.select + ")";
      selectedEntry.localLibraryLink = "(" + selectedEntry.select + ")";
    }
    selectedEntry.file = createLocalFileLink(selectedEntry);
    const entriesArray = Object.keys(selectedEntry);
    note = replaceAllTemplates(entriesArray, note, selectedEntry);
    note = note.replace(/```/g, "HEREISAPLACEHOLDERFORBACKTICK");
    note = note.replace(/`/g, "'");
    note = note.replace(/HEREISAPLACEHOLDERFORBACKTICK/g, "```");
    note = note.replace("```ad-quote\ntitle: Abstract\n```\n", "");
    note = note.replace("```ad-abstract\ntitle: Files and Links\n```\n", "");
    note = note.replace("```ad-note\ntitle: Tags and Collections\n```", "");
    return note;
  }
  parseAnnotationLinesintoElementsZotfile(note) {
    const lines = note.split(/<p>/gm);
    const noteElements = [];
    for (let indexLines = 0; indexLines < lines.length; indexLines++) {
      const selectedLineOriginal = lines[indexLines];
      const selectedLine = selectedLineOriginal.replace(/<\/?[^>]+(>|$)/g, "");
      if (selectedLine === "") {
        continue;
      }
      const lineElements = {
        highlightText: "",
        highlightColour: "",
        annotationType: "",
        citeKey: "",
        commentText: "",
        rowOriginal: selectedLine,
        rowEdited: selectedLine,
        indexNote: void 0,
        foundOld: void 0,
        positionOld: void 0,
        extractionSource: "zotfile",
        colourTextAfter: "",
        colourTextBefore: "",
        imagePath: "",
        pagePDF: 0,
        pageLabel: 0,
        attachmentURI: "",
        zoteroBackLink: "",
        annotationKey: ""
      };
      lineElements.citeKey = String(selectedLine.match(/\(([^)]+)\)+$/g));
      const posCiteKeyBegins = selectedLine.indexOf(lineElements.citeKey);
      let extractedText = "";
      if (posCiteKeyBegins !== -1) {
        extractedText = selectedLine.substring(0, posCiteKeyBegins - 1).trim();
        ["\u201C", '"', "`", "'"].forEach((quote) => extractedText = removeQuoteFromStart(quote, extractedText));
        ["\u201D", '"', "`", "'"].forEach((quote) => extractedText = removeQuoteFromEnd(quote, extractedText));
      }
      if (extractedText.startsWith("(Yellow) - ")) {
        lineElements.highlightColour = "yellow";
        extractedText = extractedText.replace("(Yellow) - ", "");
      }
      if (extractedText.startsWith("(Black) - ")) {
        lineElements.highlightColour = "black";
        extractedText = extractedText.replace("(Black) - ", "");
      }
      if (extractedText.startsWith("(White) - ")) {
        lineElements.highlightColour = "white";
        extractedText = extractedText.replace("(White) - ", "");
      }
      if (extractedText.startsWith("(Gray) - ")) {
        lineElements.highlightColour = "gray";
        extractedText = extractedText.replace("(Gray) - ", "");
      }
      if (extractedText.startsWith("(Red) - ")) {
        lineElements.highlightColour = "red";
        extractedText = extractedText.replace("(Red) - ", "");
      }
      if (extractedText.startsWith("(Orange) - ")) {
        lineElements.highlightColour = "orange";
        extractedText = extractedText.replace("(Orange) - ", "");
      }
      if (extractedText.startsWith("(Green) - ")) {
        lineElements.highlightColour = "green";
        extractedText = extractedText.replace("(Green) - ", "");
      }
      if (extractedText.startsWith("(Cyan) - ")) {
        lineElements.highlightColour = "cyan";
        extractedText = extractedText.replace("(Cyan) - ", "");
      }
      if (extractedText.startsWith("(Blue) - ")) {
        lineElements.highlightColour = "blue";
        extractedText = extractedText.replace("(Blue) - ", "");
      }
      if (extractedText.startsWith("(Magenta) - ")) {
        lineElements.highlightColour = "magenta";
        extractedText = extractedText.replace("(Magenta) - ", "");
      }
      lineElements.zoteroBackLink = "";
      if (/zotero:\/\/open-pdf\/library\/items\/\S+page=\d+/g.test(selectedLineOriginal)) {
        const zoteroBackLink = String(selectedLineOriginal.match(/zotero:\/\/open-pdf\/library\/items\/\S+page=\d+/g));
        lineElements.zoteroBackLink = zoteroBackLink;
      }
      if (/(\d+)(?!.*\d)/g.test(selectedLineOriginal)) {
        const pageLabel = String(selectedLineOriginal.match(/(\d+)(?!.*\d)/g));
        if (pageLabel == null) {
          lineElements.pageLabel = null;
        } else {
          lineElements.pageLabel = Number(pageLabel);
        }
      }
      const annotationCommentAll = "";
      if (lineElements.citeKey.includes("(note on p.")) {
        lineElements.commentText = extractedText;
        lineElements.citeKey = "";
      } else {
        lineElements.highlightText = extractedText;
      }
      let firstBlank = -1;
      let annotationCommentFirstWord = "";
      if (lineElements.commentText.length > 0) {
        firstBlank = lineElements.commentText.indexOf(" ");
        if (firstBlank === -1) {
          firstBlank = lineElements.commentText.length;
        }
        annotationCommentFirstWord = lineElements.commentText.substring(0, firstBlank);
      }
      lineElements.annotationType = this.getAnnotationType(annotationCommentFirstWord, lineElements.commentText);
      if (firstBlank == -1) {
        firstBlank = annotationCommentAll.length;
      }
      lineElements.commentText = lineElements.annotationType === "noKey" ? lineElements.commentText : lineElements.commentText.substring(firstBlank, lineElements.commentText.length).trim();
      if (noteElements.length > 1) {
        if (lineElements.annotationType != "noKey" && noteElements[noteElements.length - 1].annotationType === "noKey" && noteElements[noteElements.length - 1].commentText === "") {
          noteElements[noteElements.length - 1].annotationType = lineElements.annotationType;
          noteElements[noteElements.length - 1].commentText = lineElements.commentText;
          continue;
        }
      }
      noteElements.push(lineElements);
    }
    return noteElements;
  }
  parseAnnotationLinesintoElementsUserNote(note) {
    note = note.replace(/`/g, "'").replace(/, p. p. /g, ", p. ").trim();
    const lines = note.split(/<\/h1>|<\/p>/gm);
    const noteElements = [];
    const lengthLines = Object.keys(lines).length;
    for (let indexLines = 0; indexLines < lengthLines; indexLines++) {
      const selectedLineOriginal = unescape(lines[indexLines]);
      let selectedLine = String(selectedLineOriginal.replace(/<\/?[^>]+(>|$)/g, ""));
      selectedLine = replaceTemplate(selectedLine, "`", "'");
      selectedLine = replaceTemplate(selectedLine, "&amp;", "&");
      const lineElements = {
        highlightText: "",
        highlightColour: "",
        annotationType: "",
        citeKey: "",
        commentText: "",
        rowOriginal: selectedLine,
        rowEdited: selectedLine,
        indexNote: void 0,
        foundOld: void 0,
        positionOld: void 0,
        extractionSource: "UserNote",
        colourTextBefore: "",
        colourTextAfter: "",
        imagePath: "",
        pagePDF: 0,
        pageLabel: 0,
        attachmentURI: "",
        zoteroBackLink: "",
        annotationKey: ""
      };
      lineElements.rowEdited = selectedLine;
      noteElements.push(lineElements);
    }
    return noteElements;
  }
  parseAnnotationLinesintoElementsZotero(note) {
    note = note.replace(/`/g, "'").replace(/, p. p. /g, ", p. ").trim();
    const lines = note.split(/<\/h1>|<\/p>|<h1>/gm);
    const noteElements = [];
    const lengthLines = Object.keys(lines).length;
    for (let indexLines = 1; indexLines < lengthLines; indexLines++) {
      const selectedLineOriginal = unescape(lines[indexLines]);
      let selectedLine = String(selectedLineOriginal.replace(/<\/?[^>]+(>|$)/g, ""));
      selectedLine = replaceTemplate(selectedLine, "`", "'");
      selectedLine = replaceTemplate(selectedLine, "&amp;", "&");
      const lineElements = {
        highlightText: "",
        highlightColour: "",
        annotationType: "",
        citeKey: "",
        commentText: "",
        rowOriginal: selectedLine,
        rowEdited: selectedLine,
        indexNote: void 0,
        foundOld: void 0,
        positionOld: void 0,
        extractionSource: "zotero",
        colourTextBefore: "",
        colourTextAfter: "",
        imagePath: "",
        pagePDF: void 0,
        pageLabel: void 0,
        zoteroBackLink: "",
        attachmentURI: "",
        annotationKey: ""
      };
      lineElements.extractionSource = "zotero";
      if (/data-attachment-key=/gm.test(selectedLineOriginal)) {
        lineElements.annotationType = "typeImage";
        lineElements.imagePath = String(selectedLineOriginal.match(/key="([^"]*)"/g)[0]).replaceAll('"', "").replace("key=", "");
      }
      if (/"color":"#......"/gm.test(selectedLineOriginal)) {
        let highlightColour = String(selectedLineOriginal.match(/"color":"#......"/gm));
        if (highlightColour == null) {
          highlightColour = "";
        }
        highlightColour = highlightColour.replace('color":', "");
        highlightColour = highlightColour.replace('"', "");
        lineElements.highlightColour = highlightColour;
      }
      if (/"pageIndex":\d+/gm.test(selectedLineOriginal)) {
        let pagePDF = String(selectedLineOriginal.match(/"pageIndex":\d+/gm));
        if (pagePDF == null) {
          lineElements.pagePDF = null;
        } else {
          pagePDF = pagePDF.replace('"pageIndex":', "");
          lineElements.pagePDF = Number(pagePDF) + 1;
        }
      }
      if (/"pageLabel":"\d+/g.test(selectedLineOriginal)) {
        let pageLabel = String(selectedLineOriginal.match(/"pageLabel":"\d+/g));
        if (pageLabel == null) {
          lineElements.pageLabel = null;
        } else {
          pageLabel = pageLabel.replace('"pageLabel":"', "");
          lineElements.pageLabel = Number(pageLabel);
        }
      }
      if (/attachmentURI":"http:\/\/zotero\.org\/users\/\d+\/items\/\w+/gm.test(selectedLineOriginal)) {
        let attachmentURI = String(selectedLineOriginal.match(/attachmentURI":"http:\/\/zotero\.org\/users\/\d+\/items\/\w+/gm));
        if (attachmentURI === null) {
          lineElements.attachmentURI = null;
        } else {
          attachmentURI = attachmentURI.replace(/attachmentURI":"http:\/\/zotero\.org\/users\/\d+\/items\//gm, "");
          lineElements.attachmentURI = attachmentURI;
        }
      }
      if (/"attachmentURI":"http:\/\/zotero.org\/users\/local\/[a-zA-Z0-9]*\/items\/[a-zA-Z0-9]*/gm.test(selectedLineOriginal)) {
        let attachmentURI = String(selectedLineOriginal.match(/"attachmentURI":"http:\/\/zotero.org\/users\/local\/[a-zA-Z0-9]*\/items\/[a-zA-Z0-9]*/gm));
        if (attachmentURI === null) {
          lineElements.attachmentURI = null;
        } else {
          attachmentURI = attachmentURI.replace(/"attachmentURI":"http:\/\/zotero.org\/users\/local\/[a-zA-Z0-9]*\/items\//gm, "");
          lineElements.attachmentURI = attachmentURI;
        }
      }
      if (/"annotationKey":"[a-zA-Z0-9]+/gm.test(selectedLineOriginal)) {
        let annotationKey = String(selectedLineOriginal.match(/"annotationKey":"[a-zA-Z0-9]+/gm));
        if (annotationKey === null) {
          lineElements.annotationKey = null;
        } else {
          annotationKey = annotationKey.replace(/"annotationKey":"/gm, "");
          lineElements.annotationKey = annotationKey;
        }
      }
      if (lineElements.attachmentURI !== null && lineElements.pagePDF !== null && lineElements.annotationKey !== null) {
        lineElements.zoteroBackLink = "zotero://open-pdf/library/items/" + lineElements.attachmentURI + "?page=" + lineElements.pagePDF + "&annotation=" + lineElements.annotationKey;
      }
      if (/\(<span class="citation-item">.*<\/span>\)<\/span>/gm.test(selectedLineOriginal)) {
        lineElements.citeKey = String(selectedLineOriginal.match(/\(<span class="citation-item">.*<\/span>\)<\/span>/gm));
        lineElements.citeKey = lineElements.citeKey.replace('(<span class="citation-item">', "");
        lineElements.citeKey = lineElements.citeKey.replace("</span>)</span>", "");
        lineElements.citeKey = "(" + lineElements.citeKey + ")";
      }
      const beginningCiteKey = selectedLine.indexOf(lineElements.citeKey);
      const endCiteKey = selectedLine.indexOf(lineElements.citeKey) + lineElements.citeKey.length;
      if (endCiteKey !== 0) {
        lineElements.highlightText = selectedLine.substring(0, beginningCiteKey - 1).trim();
        lineElements.highlightText = lineElements.highlightText.replace(/((?<=\p{Unified_Ideograph})\s*(?=\p{Unified_Ideograph}))/ug, "");
        ["\u201C", '"', "`", "'"].forEach((quote) => lineElements.highlightText = removeQuoteFromStart(quote, lineElements.highlightText));
        ["\u201D", '"', "`", "'"].forEach((quote) => lineElements.highlightText = removeQuoteFromEnd(quote, lineElements.highlightText));
      }
      if (endCiteKey > 0) {
        const annotationCommentAll = selectedLine.substring(endCiteKey + 1).trim();
        let firstBlank = annotationCommentAll.indexOf(" ");
        const annotationCommentFirstWord = annotationCommentAll.substring(0, firstBlank);
        if (lineElements.annotationType !== "typeImage") {
          lineElements.annotationType = this.getAnnotationType(annotationCommentFirstWord, annotationCommentAll);
        }
        lineElements.commentText = "";
        if (firstBlank == -1) {
          firstBlank = annotationCommentAll.length;
        }
        lineElements.commentText = lineElements.annotationType === "noKey" || lineElements.annotationType === "typeImage" ? annotationCommentAll : annotationCommentAll.substring(firstBlank, annotationCommentAll.length).trim();
      } else {
        lineElements.rowEdited = selectedLine;
      }
      noteElements.push(lineElements);
    }
    return noteElements;
  }
  formatColourHighlight(lineElements) {
    if (lineElements.annotationType === "typeImage") {
      return lineElements;
    }
    if (lineElements.highlightColour.includes("#ffd400")) {
      lineElements.highlightColour = "yellow";
    }
    if (lineElements.highlightColour.includes("#ff6666")) {
      lineElements.highlightColour = "red";
    }
    if (lineElements.highlightColour.includes("#5fb236")) {
      lineElements.highlightColour = "green";
    }
    if (lineElements.highlightColour.includes("#2ea8e5")) {
      lineElements.highlightColour = "blue";
    }
    if (lineElements.highlightColour.includes("#a28ae5")) {
      lineElements.highlightColour = "purple";
    }
    if (lineElements.highlightColour.includes("#000000")) {
      lineElements.highlightColour = "black";
    }
    if (lineElements.highlightColour.includes("##FFFFFF")) {
      lineElements.highlightColour = "white";
    }
    if (lineElements.highlightColour.includes("##808080")) {
      lineElements.highlightColour = "gray";
    }
    if (lineElements.highlightColour.includes("##FF0000")) {
      lineElements.highlightColour = "red";
    }
    if (lineElements.highlightColour.includes("##FFA500")) {
      lineElements.highlightColour = "orange";
    }
    if (lineElements.highlightColour.includes("##FFFF00")) {
      lineElements.highlightColour = "yellow";
    }
    if (lineElements.highlightColour.includes("##00FF00")) {
      lineElements.highlightColour = "green";
    }
    if (lineElements.highlightColour.includes("##00FFFF")) {
      lineElements.highlightColour = "cyan";
    }
    if (lineElements.highlightColour.includes("##0000FF")) {
      lineElements.highlightColour = "blue";
    }
    if (lineElements.highlightColour.includes("##FF00FF")) {
      lineElements.highlightColour = "magenta";
    }
    let colourTransformation = "";
    if (lineElements.highlightColour == "yellow") {
      colourTransformation = this.settings.colourYellowText;
    }
    if (lineElements.highlightColour == "red") {
      colourTransformation = this.settings.colourRedText;
    }
    if (lineElements.highlightColour == "green") {
      colourTransformation = this.settings.colourGreenText;
    }
    if (lineElements.highlightColour == "blue") {
      colourTransformation = this.settings.colourBlueText;
    }
    if (lineElements.highlightColour == "purple") {
      colourTransformation = this.settings.colourPurpleText;
    }
    if (lineElements.highlightColour == "black") {
      colourTransformation = this.settings.colourBlackText;
    }
    if (lineElements.highlightColour == "white") {
      colourTransformation = this.settings.colourWhiteText;
    }
    if (lineElements.highlightColour == "gray") {
      colourTransformation = this.settings.colourGrayText;
    }
    if (lineElements.highlightColour == "orange") {
      colourTransformation = this.settings.colourOrangeText;
    }
    if (lineElements.highlightColour == "cyan") {
      colourTransformation = this.settings.colourCyanText;
    }
    if (lineElements.highlightColour == "magenta") {
      colourTransformation = this.settings.colourMagentaText;
    }
    if (lineElements.annotationType == "noKey") {
      if (colourTransformation.toLowerCase() === "h1") {
        lineElements.annotationType = "typeH1";
      } else if (colourTransformation.toLowerCase() === "h2") {
        lineElements.annotationType = "typeH2";
      } else if (colourTransformation.toLowerCase() === "h3") {
        lineElements.annotationType = "typeH3";
      } else if (colourTransformation.toLowerCase() === "h4") {
        lineElements.annotationType = "typeH4";
      } else if (colourTransformation.toLowerCase() === "h5") {
        lineElements.annotationType = "typeH5";
      } else if (colourTransformation.toLowerCase() === "h6") {
        lineElements.annotationType = "typeH6";
      } else if (colourTransformation.toLowerCase() === "addtoabove") {
        lineElements.annotationType = "typeMergeAbove";
      } else if (colourTransformation.toLowerCase() === "keyword") {
        lineElements.annotationType = "typeKeyword";
      } else if (colourTransformation.toLowerCase() === "todo") {
        lineElements.annotationType = "typeTask";
      } else if (colourTransformation.toLowerCase() === "task") {
        lineElements.annotationType = "typeTask";
      }
    }
    if (colourTransformation.includes("{{highlight}}")) {
      lineElements.colourTextBefore = String(colourTransformation.match(/.+?(?={{highlight}})/));
      if (lineElements.colourTextBefore == "null") {
        lineElements.colourTextBefore = "";
      }
      lineElements.colourTextAfter = String(colourTransformation.match(/(?<={{highlight}}).*$/));
      if (lineElements.colourTextAfter == "null") {
        lineElements.colourTextAfter = "";
      }
    }
    return lineElements;
  }
  formatNoteElements(noteElements, citeKey) {
    const { isDoubleSpaced } = this.settings;
    const {
      commentFormatAfter,
      commentFormatBefore,
      commentPrepend,
      highlightFormatAfter,
      highlightFormatBefore,
      highlightPrepend
    } = this.createFormatting();
    const indexRowsToBeRemoved = [];
    const noteElementsArray = [];
    const keywordArray = [];
    const rowEditedArray = [];
    const highlightsYellow = [];
    const highlightsRed = [];
    const highlightsGreen = [];
    const highlightsPurple = [];
    const highlightsBlack = [];
    const highlightsWhite = [];
    const highlightsGray = [];
    const highlightsCyan = [];
    const highlightsOrange = [];
    const highlightsBlue = [];
    const highlightsMagenta = [];
    const imagesArray = [];
    noteElements = noteElements.filter((x) => x !== void 0);
    for (let i = 0; i < noteElements.length; i++) {
      let lineElements = noteElements[i];
      lineElements = this.formatColourHighlight(lineElements);
      if (lineElements.extractionSource === "zotero" || lineElements.extractionSource === "zotfile") {
        if (this.settings.highlightCitationsFormat === "Only page number" && lineElements.pageLabel !== void 0) {
          lineElements.citeKey = "(p. " + lineElements.pageLabel + ")";
        } else if (this.settings.highlightCitationsFormat === "Pandoc" && lineElements.pageLabel !== void 0) {
          lineElements.citeKey = "[@" + citeKey + ", p. " + lineElements.pageLabel + "]";
        } else if (this.settings.highlightCitationsFormat === "Pandoc" && lineElements.pageLabel === void 0) {
          lineElements.citeKey = "[@" + citeKey + "]";
        } else if (this.settings.highlightCitationsFormat === "Empty" && lineElements.pageLabel !== void 0) {
          lineElements.citeKey = " ";
        }
      }
      if (this.settings.highlightCitationsLink === true && lineElements.zoteroBackLink.length > 0) {
        if (this.settings.highlightCitationsFormat !== "Pandoc") {
          lineElements.citeKey = "[" + lineElements.citeKey + "](" + lineElements.zoteroBackLink + ")";
          lineElements.zoteroBackLink = "[ ](" + lineElements.zoteroBackLink + ")";
        } else {
          lineElements.citeKey = lineElements.citeKey + " [](" + lineElements.zoteroBackLink + ")";
          lineElements.zoteroBackLink = "[ ](" + lineElements.zoteroBackLink + ")";
        }
      } else {
        lineElements.zoteroBackLink = "";
      }
      let colourTextBefore = lineElements.colourTextBefore;
      if (colourTextBefore == void 0) {
        colourTextBefore = "";
      }
      let colourTextAfter = lineElements.colourTextAfter;
      if (colourTextAfter == void 0) {
        colourTextAfter = "";
      }
      if (lineElements.highlightText === "Extracted Annotations") {
        lineElements.annotationType = "typeExtractedHeading";
      }
      if (lineElements.annotationType === "typeExtractedHeading") {
        lineElements.rowEdited = "**" + lineElements.rowOriginal.toUpperCase() + "**";
      }
      if (lineElements.annotationType === "typeImage") {
        lineElements.rowEdited = "";
        let pathImageOld = "";
        let pathImageNew = "";
        if (this.settings.imagesImport) {
          pathImageOld = import_path2.default.format({
            dir: this.pathZoteroStorage + lineElements.imagePath,
            base: "image.png"
          });
          pathImageNew = import_path2.default.normalize(import_path2.default.format({
            dir: (0, import_obsidian6.normalizePath)(this.app.vault.adapter.getBasePath() + "\\" + this.settings.imagesPath),
            base: citeKey + "_" + lineElements.imagePath + ".png"
          }));
          if (this.zoteroBuildWindows != true) {
            pathImageNew = "/" + pathImageNew;
          }
          if (fs2.existsSync(pathImageOld) || fs2.existsSync(pathImageNew)) {
            if (this.settings.imagesCopy === false) {
              lineElements.rowEdited = "![](file://" + pathImageOld + ")" + lineElements.zoteroBackLink;
            } else {
              if (!fs2.existsSync(pathImageNew)) {
                fs2.copyFile(pathImageOld, pathImageNew, (err) => {
                  if (err)
                    throw err;
                });
              }
              lineElements.rowEdited = "![[" + citeKey + "_" + lineElements.imagePath + ".png]] " + lineElements.citeKey;
            }
          } else {
            new import_obsidian6.Notice(`Cannot find image at "${pathImageOld}". Provide the correct zotero data directory location in the settings`);
          }
        }
        if (lineElements.commentText.length > 0) {
          if (this.settings.imagesCommentPosition == "Below the image") {
            lineElements.rowEdited = lineElements.rowEdited + "\n\n" + commentPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter;
          } else {
            lineElements.rowEdited = commentPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter + "\n\n" + lineElements.rowEdited;
          }
        }
      }
      if (lineElements.annotationType === "typeMergeAbove") {
        noteElements[i].rowEdited = (noteElements[i - 1].rowEdited.replace(/\[.*\)/, "") + this.settings.highlightCustomTextBefore + colourTextBefore + highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + lineElements.zoteroBackLink + colourTextAfter).replace(/((?<=\p{Unified_Ideograph})\s*(?=\p{Unified_Ideograph}))/ug, "");
        indexRowsToBeRemoved.push(i - 1);
      }
      if (this.settings.commentPrependDefault === true && lineElements.highlightText !== "" && lineElements.commentText !== "") {
        lineElements.annotationType = "typeCommentPrepend";
      }
      if (lineElements.annotationType === "typeCommentPrepend") {
        lineElements.rowEdited = highlightPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter + this.settings.commentPrependDivider + colourTextBefore + highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + lineElements.citeKey + colourTextAfter;
      }
      if (/typeH\d/.test(lineElements.annotationType)) {
        const lastChar = lineElements.annotationType[lineElements.annotationType.length - 1];
        const level = parseInt(lastChar);
        const hashes = "#".repeat(level);
        lineElements.rowEdited = `
${hashes} ` + lineElements.highlightText + lineElements.commentText + lineElements.zoteroBackLink;
      }
      if (lineElements.annotationType == "typeTask") {
        if (lineElements.commentText !== "" && lineElements.highlightText !== "") {
          lineElements.rowEdited = `- [ ] ` + commentFormatBefore + lineElements.commentText + commentFormatAfter + " - " + colourTextBefore + highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + lineElements.zoteroBackLink + colourTextAfter;
        } else if (lineElements.commentText == "" && lineElements.highlightColour !== "") {
          lineElements.rowEdited = `- [ ] ` + colourTextBefore + highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + lineElements.zoteroBackLink + colourTextAfter;
        } else if (lineElements.commentText !== "" && lineElements.highlightColour === "") {
          lineElements.rowEdited = `- [ ] ` + commentFormatBefore + lineElements.commentText + commentFormatAfter + lineElements.zoteroBackLink;
        }
      }
      if (lineElements.annotationType === "typeKeyword") {
        keywordArray.push(lineElements.highlightText);
        lineElements.rowEdited = "";
        indexRowsToBeRemoved.push(i);
      }
      if (lineElements.annotationType === "noKey") {
        if (lineElements.highlightText !== "") {
          lineElements.rowEdited = highlightPrepend + colourTextBefore + highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + lineElements.citeKey + colourTextAfter;
          if (lineElements.commentText !== "") {
            lineElements.rowEdited = lineElements.rowEdited + commentPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter;
          }
        } else if (lineElements.highlightText === "" && lineElements.commentText !== "") {
          lineElements.rowEdited = commentPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter + lineElements.zoteroBackLink;
        }
      }
      noteElementsArray.push(lineElements);
    }
    if (indexRowsToBeRemoved.length) {
      for (let index = indexRowsToBeRemoved.length - 1; index >= 0; index--) {
        noteElementsArray.splice(indexRowsToBeRemoved[index], 1);
      }
    }
    for (let index = 0; index < noteElementsArray.length; index++) {
      const selectedLine = noteElementsArray[index];
      rowEditedArray.push(selectedLine.rowEdited);
      if (selectedLine.highlightColour === "yellow") {
        highlightsYellow.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "red") {
        highlightsRed.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "green") {
        highlightsGreen.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "purple") {
        highlightsPurple.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "black") {
        highlightsBlack.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "white") {
        highlightsWhite.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "gray") {
        highlightsGray.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "cyan") {
        highlightsCyan.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "orange") {
        highlightsOrange.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "blue") {
        highlightsBlue.push(selectedLine.rowEdited);
      } else if (selectedLine.highlightColour === "magenta") {
        highlightsMagenta.push(selectedLine.rowEdited);
      }
      if (selectedLine.annotationType === "typeImage") {
        imagesArray.push(selectedLine.rowEdited);
      }
    }
    if (isDoubleSpaced) {
      for (let index = rowEditedArray.length - 1; index >= 0; index--) {
        rowEditedArray.splice(index, 0, "");
      }
    }
    const resultsLineElements = {
      rowEditedArray,
      keywordArray,
      highlightsYellow,
      highlightsRed,
      highlightsGreen,
      highlightsPurple,
      highlightsBlack,
      highlightsWhite,
      highlightsGray,
      highlightsCyan,
      highlightsOrange,
      highlightsBlue,
      highlightsMagenta,
      imagesArray,
      noteElements
    };
    return resultsLineElements;
  }
  getAnnotationType(annotationCommentFirstWord, annotationCommentAll) {
    const {
      keyMergeAbove,
      keyCommentPrepend,
      keyH1,
      keyH2,
      keyH3,
      keyH4,
      keyH5,
      keyH6,
      keyKeyword,
      keyTask
    } = this.settings;
    annotationCommentFirstWord = annotationCommentFirstWord.toLowerCase();
    let annotationType = "noKey";
    if (annotationCommentFirstWord === keyMergeAbove.toLowerCase() || annotationCommentAll === keyMergeAbove) {
      annotationType = "typeMergeAbove";
    } else if (annotationCommentFirstWord === keyCommentPrepend.toLowerCase()) {
      annotationType = "typeCommentPrepend";
    } else if (annotationCommentFirstWord === keyH1.toLowerCase()) {
      annotationType = "typeH1";
    } else if (annotationCommentFirstWord === keyH2.toLowerCase()) {
      annotationType = "typeH2";
    } else if (annotationCommentFirstWord === keyH3.toLowerCase()) {
      annotationType = "typeH3";
    } else if (annotationCommentFirstWord === keyH4.toLowerCase()) {
      annotationType = "typeH4";
    } else if (annotationCommentFirstWord === keyH5.toLowerCase()) {
      annotationType = "typeH5";
    } else if (annotationCommentFirstWord === keyH6.toLowerCase()) {
      annotationType = "typeH6";
    }
    if (annotationCommentAll === keyH1.toLowerCase()) {
      annotationType = "typeH1";
    } else if (annotationCommentAll === keyH2.toLowerCase()) {
      annotationType = "typeH2";
    } else if (annotationCommentAll === keyH3.toLowerCase()) {
      annotationType = "typeH3";
    } else if (annotationCommentAll === keyH4.toLowerCase()) {
      annotationType = "typeH4";
    } else if (annotationCommentAll === keyH5.toLowerCase()) {
      annotationType = "typeH5";
    } else if (annotationCommentAll === keyH6.toLowerCase()) {
      annotationType = "typeH6";
    } else if (annotationCommentAll === keyKeyword.toLowerCase() || annotationCommentFirstWord === keyKeyword.toLowerCase()) {
      annotationType = "typeKeyword";
    } else if (annotationCommentAll === keyTask.toLowerCase() || annotationCommentFirstWord === keyTask.toLowerCase()) {
      annotationType = "typeTask";
    }
    return annotationType;
  }
  extractAnnotation(selectedEntry, noteTitleFull) {
    let extractedAnnotations = "";
    let extractedAnnotationsYellow = "";
    let extractedAnnotationsRed = "";
    let extractedAnnotationsGreen = "";
    let extractedAnnotationsBlue = "";
    let extractedAnnotationsPurple = "";
    let extractedAnnotationsBlack = "";
    let extractedAnnotationsWhite = "";
    let extractedAnnotationsGray = "";
    let extractedAnnotationsCyan = "";
    let extractedAnnotationsOrange = "";
    let extractedAnnotationsMagenta = "";
    let extractedImages = "";
    let extractedUserNote = "";
    if (selectedEntry.attachments[0] !== void 0) {
      let pathZoteroStorage = "";
      let zoteroBuildWindows = void 0;
      const zoteroStorageMac = new RegExp(/.+?(?=Zotero\/storage)Zotero\/storage\//gm);
      if (zoteroStorageMac.test(selectedEntry.attachments[0].path)) {
        pathZoteroStorage = String(selectedEntry.attachments[0].path.match(zoteroStorageMac));
        zoteroBuildWindows = false;
      }
      const zoteroStorageWindows = new RegExp(/.+?(?=Zotero\\storage\\)Zotero\\storage\\/gm);
      if (zoteroStorageWindows.test(selectedEntry.attachments[0].path)) {
        pathZoteroStorage = String(selectedEntry.attachments[0].path.match(zoteroStorageWindows));
        zoteroBuildWindows = true;
      }
      if (pathZoteroStorage.length == 0 && this.settings.zoteroStoragePathManual.length > 0) {
        pathZoteroStorage = this.settings.zoteroStoragePathManual;
        if (pathZoteroStorage.toLowerCase().endsWith("\\zotero")) {
          pathZoteroStorage = pathZoteroStorage + "\\storage\\";
        }
        if (pathZoteroStorage.toLowerCase().endsWith("\\zotero\\")) {
          pathZoteroStorage = pathZoteroStorage + "storage\\";
        }
        if (pathZoteroStorage.toLowerCase().endsWith("/zotero")) {
          pathZoteroStorage = pathZoteroStorage + "/storage/";
        }
        if (pathZoteroStorage.toLowerCase().endsWith("/zotero/")) {
          pathZoteroStorage = pathZoteroStorage + "storage/";
        }
      }
      this.pathZoteroStorage = pathZoteroStorage;
      this.zoteroBuildWindows = zoteroBuildWindows;
    }
    let noteElements = [];
    let userNoteElements = [];
    if (selectedEntry.notes.length > 0) {
      for (let indexNote = 0; indexNote < selectedEntry.notes.length; indexNote++) {
        let note = selectedEntry.notes[indexNote].note;
        note = note.replaceAll("$&", "$ &");
        let extractionType = void 0;
        if (unescape(note).includes("<span class=")) {
          extractionType = "Zotero";
        } else if (unescape(note).includes('<a href="zotero://open-pdf/library/')) {
          extractionType = "Zotfile";
        } else if (unescape(note).includes("div data-schema-version")) {
          extractionType = "UserNote";
        } else {
          extractionType = "Other";
        }
        let noteElementsSingle = [];
        if (extractionType === "Zotero") {
          noteElementsSingle = this.parseAnnotationLinesintoElementsZotero(note);
          noteElements = noteElements.concat(noteElementsSingle);
        }
        if (extractionType === "Zotfile") {
          noteElementsSingle = this.parseAnnotationLinesintoElementsZotfile(note);
          noteElements = noteElements.concat(noteElementsSingle);
        }
        if (extractionType === "UserNote" || extractionType === "Other") {
          noteElementsSingle = this.parseAnnotationLinesintoElementsUserNote(note);
          userNoteElements = userNoteElements.concat(noteElementsSingle);
        }
        this.noteElements = noteElements;
        this.userNoteElements = userNoteElements;
      }
      const resultsLineElements = this.formatNoteElements(this.noteElements, selectedEntry.citationKey);
      this.keyWordArray = resultsLineElements.keywordArray;
      extractedAnnotations = resultsLineElements.rowEditedArray.join("\n");
      extractedAnnotationsYellow = resultsLineElements.highlightsYellow.join("\n");
      extractedAnnotationsRed = resultsLineElements.highlightsRed.join("\n");
      extractedAnnotationsGreen = resultsLineElements.highlightsGreen.join("\n");
      extractedAnnotationsBlue = resultsLineElements.highlightsBlue.join("\n");
      extractedAnnotationsPurple = resultsLineElements.highlightsPurple.join("\n");
      extractedAnnotationsBlack = resultsLineElements.highlightsBlack.join("\n");
      extractedAnnotationsWhite = resultsLineElements.highlightsWhite.join("\n");
      extractedAnnotationsGray = resultsLineElements.highlightsGray.join("\n");
      extractedAnnotationsCyan = resultsLineElements.highlightsCyan.join("\n");
      extractedAnnotationsOrange = resultsLineElements.highlightsOrange.join("\n");
      extractedAnnotationsMagenta = resultsLineElements.highlightsMagenta.join("\n");
      extractedImages = resultsLineElements.imagesArray.join("\n");
      const extractedUserNoteArray = Array.from(Object.values(this.userNoteElements), (note) => note.rowEdited);
      extractedUserNote = extractedUserNoteArray.join("\n");
    }
    const extractedNote = {
      extractedAnnotations,
      extractedUserNote,
      extractedKeywords: this.keyWordArray,
      extractedAnnotationsYellow,
      extractedAnnotationsRed,
      extractedAnnotationsGreen,
      extractedAnnotationsBlue,
      extractedAnnotationsPurple,
      extractedAnnotationsBlack,
      extractedAnnotationsWhite,
      extractedAnnotationsGray,
      extractedAnnotationsCyan,
      extractedAnnotationsOrange,
      extractedAnnotationsMagenta,
      extractedImages,
      noteElements: this.noteElements
    };
    return extractedNote;
  }
  parseCollection(selectedEntry, data, metadata) {
    const exportedCollections = data.collections;
    const selectedID = selectedEntry.itemID;
    let collectionArray = [];
    const collectionParentCode = [];
    let collectionParentArray = [];
    const collectionParentParent = [];
    const collectionKeys = Object.keys(exportedCollections);
    for (let indexCollection = 0; indexCollection < collectionKeys.length; indexCollection++) {
      const collectionName = exportedCollections[collectionKeys[indexCollection]].name;
      const collectionItem = exportedCollections[collectionKeys[indexCollection]].items;
      const collectionParent = exportedCollections[collectionKeys[indexCollection]].parent;
      if (collectionItem.includes(selectedID)) {
        collectionArray.push(collectionName);
        collectionParentCode.push(collectionParent);
      }
    }
    if (collectionParentCode.length > 0) {
      for (let indexCollection = 0; indexCollection < collectionKeys.length; indexCollection++) {
        if (collectionParentCode.includes(exportedCollections[collectionKeys[indexCollection]].key)) {
          collectionParentArray.push(exportedCollections[collectionKeys[indexCollection]].name);
        }
      }
    }
    if (collectionParentParent.length > 0) {
      for (let indexCollection = 0; indexCollection < collectionKeys.length; indexCollection++) {
        if (collectionParentParent.includes(exportedCollections[collectionKeys[indexCollection]].key)) {
          collectionParentArray.push(exportedCollections[collectionKeys[indexCollection]].name);
        }
      }
    }
    collectionParentArray = collectionParentArray.concat(collectionArray);
    collectionArray = collectionArray.sort();
    collectionParentArray = collectionParentArray.sort();
    let divider = this.settings.multipleFieldsDivider;
    if (divider.slice(-1) !== " ") {
      divider = divider + " ";
    }
    if (collectionArray.length > 0) {
      const collectionArrayBraket = collectionArray.map(makeWiki);
      metadata = replaceTemplate(metadata, `[[{{collections}}]]`, String(collectionArrayBraket.join(divider)));
      const collectionArrayQuotes = collectionArray.map(makeQuotes);
      metadata = replaceTemplate(metadata, `"{{collections}}"`, String(collectionArrayQuotes.join(divider)));
      const collectionArrayTags = collectionArray.map(makeTags);
      metadata = replaceTemplate(metadata, `#{{collections}}`, String(collectionArrayTags.join(divider)));
      metadata = replaceTemplate(metadata, `{{collections}}`, String(collectionArray.join(divider)));
    }
    if (collectionParentArray.length > 0) {
      const collectionParentArrayBraket = collectionParentArray.map(makeWiki);
      metadata = replaceTemplate(metadata, `[[{{collectionsParent}}]]`, String(collectionParentArrayBraket.join(divider)));
      const collectionParentArrayQuotes = collectionParentArray.map(makeQuotes);
      metadata = replaceTemplate(metadata, `"{{collectionsParent}}"`, String(collectionParentArrayQuotes.join(divider)));
      const collectionParentArrayTags = collectionParentArray.map(makeTags);
      metadata = replaceTemplate(metadata, `#{{collectionsParent}}`, String(collectionParentArrayTags.join(divider)));
      metadata = replaceTemplate(metadata, `{{collectionsParent}}`, String(collectionParentArray.join(divider)));
    }
    return metadata;
  }
  importTemplate() {
    let template = templatePlain;
    if (this.settings.templateType === "Plain") {
      template = templatePlain;
    } else if (this.settings.templateType === "Admonition") {
      template = templateAdmonition;
    } else if (this.settings.templateType === "Custom") {
      template = this.settings.templateContent;
    }
    return template;
  }
  compareOldNewNote(existingNote, newNote, authorKey) {
    const newLineRegex = RegExp(/\n/gm);
    const positionNewLine = [];
    let match = void 0;
    while (match = newLineRegex.exec(existingNote)) {
      positionNewLine.push(match.index);
    }
    const positionOldNote = [0];
    const newNoteInsertText = [];
    const newNoteInsertPosition = [];
    const newNoteArray = newNote.split("\n");
    for (let indexLines = 0; indexLines < newNoteArray.length; indexLines++) {
      let segmentWhole = "";
      let segmentFirstHalf = "";
      let segmentSecondHalf = "";
      let segmentFirstQuarter = "";
      let segmentSecondQuarter = "";
      let segmentThirdQuarter = "";
      let segmentFourthQuarter = "";
      const positionArray = [-1];
      let selectedNewLine = newNoteArray[indexLines];
      selectedNewLine = selectedNewLine.trim();
      selectedNewLine = selectedNewLine.replace(/^- /gm, "");
      selectedNewLine = selectedNewLine.replace(/^> /gm, "");
      selectedNewLine = selectedNewLine.replace(/^=/gm, "");
      selectedNewLine = selectedNewLine.replace(/^\**/gm, "");
      selectedNewLine = selectedNewLine.replace(/^\*/gm, "");
      selectedNewLine = selectedNewLine.replace(/^"/gm, "");
      const authorKey_Zotero = new RegExp("\\(" + authorKey + ", \\d+, p. \\d+\\)$");
      const authorKey_Zotfile = new RegExp("\\(" + authorKey + " \\d+:\\d+\\)$");
      selectedNewLine = selectedNewLine.replace(authorKey_Zotero, "");
      selectedNewLine = selectedNewLine.replace(authorKey_Zotfile, "");
      selectedNewLine = selectedNewLine.replace(/=$/gm, "");
      selectedNewLine = selectedNewLine.replace(/\**$/gm, "");
      selectedNewLine = selectedNewLine.replace(/\*$/gm, "");
      selectedNewLine = selectedNewLine.replace(/"$/gm, "");
      if (selectedNewLine == void 0) {
        continue;
      }
      const lengthExistingLine = selectedNewLine.length;
      if (lengthExistingLine === 0) {
        continue;
      }
      if (lengthExistingLine > 1 && lengthExistingLine < 30) {
        segmentWhole = selectedNewLine;
        positionArray.push(existingNote.indexOf(segmentWhole));
      } else if (lengthExistingLine >= 30 && lengthExistingLine < 150) {
        segmentFirstHalf = selectedNewLine.substring(0, lengthExistingLine / 2);
        positionArray.push(existingNote.indexOf(segmentFirstHalf));
        segmentSecondHalf = selectedNewLine.substring(lengthExistingLine / 2 + 1, lengthExistingLine);
        positionArray.push(existingNote.indexOf(segmentSecondHalf));
      } else if (lengthExistingLine >= 150) {
        segmentFirstQuarter = selectedNewLine.substring(0, lengthExistingLine / 4);
        positionArray.push(existingNote.indexOf(segmentFirstQuarter));
        segmentSecondQuarter = selectedNewLine.substring(lengthExistingLine / 4 + 1, lengthExistingLine / 2);
        positionArray.push(existingNote.indexOf(segmentSecondQuarter));
        segmentThirdQuarter = selectedNewLine.substring(lengthExistingLine / 2 + 1, 3 * lengthExistingLine / 4);
        positionArray.push(existingNote.indexOf(segmentThirdQuarter));
        segmentFourthQuarter = selectedNewLine.substring(3 * lengthExistingLine / 4 + 1, lengthExistingLine);
        positionArray.push(existingNote.indexOf(segmentFourthQuarter));
      }
      if (Math.max(...positionArray) > -1) {
        const positionOldNoteMax = Math.max(...positionArray);
        positionOldNote.push(positionOldNoteMax);
      }
      if (Math.max(...positionArray) === -1) {
        const positionOldNoteMax = Math.max(...positionOldNote);
        newNoteInsertText.push(newNoteArray[indexLines]);
        newNoteInsertPosition.push(positionNewLine.filter((pos) => pos > positionOldNoteMax)[0]);
      }
    }
    let doubleSpaceAdd = "";
    if (this.settings.isDoubleSpaced) {
      doubleSpaceAdd = "\n";
    }
    for (let indexNoteElements = newNoteInsertText.length - 1; indexNoteElements >= 0; indexNoteElements--) {
      const insertText = newNoteInsertText[indexNoteElements];
      const insertPosition = newNoteInsertPosition[indexNoteElements];
      existingNote = existingNote.slice(0, insertPosition) + doubleSpaceAdd + insertText + existingNote.slice(insertPosition);
    }
    if (this.settings.saveManualEdits == "Save Entire Note") {
      return existingNote;
    }
    if (this.settings.saveManualEdits == "Select Section") {
      const startSave = this.settings.saveManualEditsStart;
      const endSave = this.settings.saveManualEditsEnd;
      let startSaveOld = 0;
      if (startSave !== "") {
        startSaveOld = existingNote.indexOf(startSave);
      }
      if (startSaveOld < 0) {
        startSaveOld = 0;
      }
      let endSaveOld = existingNote.length - 1;
      if (endSave !== "") {
        endSaveOld = existingNote.indexOf(endSave) - 1;
      }
      if (endSaveOld < 0) {
        endSaveOld = existingNote.length - 1;
      }
      const existingNotePreserved = existingNote.substring(startSaveOld, endSaveOld);
      let startSaveNew = 0;
      if (startSave !== "") {
        startSaveNew = newNote.indexOf(startSave);
      }
      if (startSaveNew < 0) {
        startSaveNew = 0;
      }
      let endSaveNew = newNote.length - 1;
      if (endSave !== "") {
        endSaveNew = newNote.indexOf(endSave) - 1;
      }
      if (endSaveNew < 0) {
        endSaveNew = newNote.length - 1;
      }
      const newNotePreservedBefore = newNote.substring(0, startSaveNew);
      const newNotePreservedAfter = newNote.substring(endSaveNew, newNote.length - 1);
      const newNoteCombined = newNotePreservedBefore + existingNotePreserved + newNotePreservedAfter;
      return newNoteCombined;
    }
  }
  createNote(selectedEntry, data) {
    const authorKey = createAuthorKey(selectedEntry.creators);
    selectedEntry.authorKey = authorKey;
    let bugout = new Debugout({ realTimeLoggingOn: false });
    if (this.settings.debugMode === true) {
      bugout = new Debugout({ realTimeLoggingOn: true });
    }
    const templateNote = this.importTemplate();
    bugout.log("Template: \n" + templateNote);
    let litnote = this.parseMetadata(selectedEntry, templateNote);
    bugout.log(selectedEntry);
    litnote = this.parseCollection(selectedEntry, data, litnote);
    const noteTitleFull = createNoteTitle(selectedEntry, this.settings.exportTitle, this.settings.exportPath);
    const resultAnnotations = this.extractAnnotation(selectedEntry, noteTitleFull);
    bugout.log(resultAnnotations.noteElements);
    litnote = litnote.replace("{{PDFNotes}}", resultAnnotations.extractedAnnotations);
    litnote = litnote.replace("{{UserNotes}}", resultAnnotations.extractedUserNote);
    litnote = litnote.replace("{{Yellow}}", resultAnnotations.extractedAnnotationsYellow);
    litnote = litnote.replace("{{Red}}", resultAnnotations.extractedAnnotationsRed);
    litnote = litnote.replace("{{Green}}", resultAnnotations.extractedAnnotationsGreen);
    litnote = litnote.replace("{{Blue}}", resultAnnotations.extractedAnnotationsBlue);
    litnote = litnote.replace("{{Purple}}", resultAnnotations.extractedAnnotationsPurple);
    litnote = litnote.replace("{{Black}}", resultAnnotations.extractedAnnotationsBlack);
    litnote = litnote.replace("{{White}}", resultAnnotations.extractedAnnotationsWhite);
    litnote = litnote.replace("{{Gray}}", resultAnnotations.extractedAnnotationsGray);
    litnote = litnote.replace("{{Cyan}}", resultAnnotations.extractedAnnotationsCyan);
    litnote = litnote.replace("{{Orange}}", resultAnnotations.extractedAnnotationsOrange);
    litnote = litnote.replace("{{Magenta}}", resultAnnotations.extractedAnnotationsMagenta);
    litnote = litnote.replace("{{Images}}", resultAnnotations.extractedImages);
    let extractedKeywords = resultAnnotations.extractedKeywords;
    if (extractedKeywords == void 0) {
      extractedKeywords = [];
    }
    litnote = replaceTagList(selectedEntry, extractedKeywords, litnote, this.settings.multipleFieldsDivider);
    const missingFieldSetting = this.settings.missingfield;
    litnote = replaceMissingFields(litnote, missingFieldSetting, this.settings.missingfieldreplacement);
    if (this.settings.saveManualEdits !== "Overwrite Entire Note" && fs2.existsSync(noteTitleFull)) {
      const existingNoteAll = String(fs2.readFileSync(noteTitleFull));
      litnote = this.compareOldNewNote(existingNoteAll, litnote, authorKey);
    }
    bugout.log("NoteTitleFull: " + noteTitleFull);
    bugout.log("Final Note: " + litnote);
    bugout.log(this.settings);
    if (this.settings.debugMode === true) {
      bugout.downloadLog();
    }
    fs2.writeFile(noteTitleFull, litnote, function(err) {
      if (err)
        console.log(err);
    });
    new import_obsidian6.Notice(`Imported ${selectedEntry.citationKey}!`);
  }
};
