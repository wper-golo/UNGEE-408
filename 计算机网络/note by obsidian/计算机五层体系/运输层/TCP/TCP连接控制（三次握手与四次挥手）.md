#TCP #运输层 #笔记 #原理 #三次握手 #四次挥手

是各大公司面试常见的问题，也是考研题型常见的东西。

# 三次握手

**意义**：为了在不可靠的信道上建立可靠的连接。

三次握手，顾名思义，有三个过程：
- 第一次握手：客户端希望与服务端建立连接，于是客户端向服务端发送SYN报文
- 第二次握手：服务端收到客户端发来的SYN报文，同意其请求，返回SYN+ACK报文
- 第三次握手：客户端收到服务端发来的SYN+ACK报文，向服务端再次发送ACK报文，完成连接的建立。

## 第一次握手

首先是客户端希望与某一个服务端建立TCP连接，初始化序号，向服务端发起TCP连接请求，这个请求就是一个**SYN报文**（一个特殊的TCP报文，该报文中SYN=1，序号seq为要建立的连接的初始序号，消耗了一个序号，不可携带任何数据）
客户端发送完SYN报文段之后，进入**SYN_SEND状态**

第一次的报文：SYN=1 seq=x

## 第二次握手

服务端收到客户端想要建立连接的请求，即客户端的SYN报文，随即初始化序号（ISN，Initnal Sequence Number），以自己的SYN报文段应答，同时将该报文中的ACK位 置1，确认号为x+1以向客户端表示自己收到了客户端发来的SYN报文，此报文同样不可携带任何数据
服务端发送完SYN+ACK报文之后，进入**SYN_RECV状态**

第二次的报文：SYN=1 ACK=1 seq=y ack=x+1

## 第三次握手

客户端收到服务端发来的SYN+ACK报文，向服务端发送ACK报文表示自己收到第二次的报文，然后进入**ESTABLISHED**状态（该ACK报文可以携带数据）

第三次的报文：ACK=1 ack=y+1

## 建立连接

服务端收到第三次的报文，同样进入**ESTABLISHED**状态，双方正式建立完成连接

## 流程图

![[image-20221018205000481.png]]

# 对于三次握手的理解

## 存在的意义

很生动的例子

首先，要建立连接的双方都对自己没有一个很清的认识，必须认清自己的能力，才能建立可靠连接
- 第一次握手
	- 客户端：我发了信息，我发送能力可以
	- 服务端：我收到了信息（SYN=1），你发送能力可以，我接收能力可以
- 第二次握手
	- 客户端：我收到信息（SYN=1），我接收能力可以，你发送能力可以；你接到我的信息（ack=x+1），你接收能力可以
	- 服务端：我发送信息，我发送能力也可以
	- 客户端单方面信任了服务端的可信发送与接收，因为在他看来，自己发送接受可以，对方发送接受可以
	- 此时服务端，还没有承认客户端的接收能力，因为他不知道客户端收没收到他发的包
- 第三次握手
	- 服务端：你收到我发的信息（ack=y+1），你接收能力可以
	- 双方信任，建立可信传输

就这样，双方开始相互信任的发送信息~

## 一些三次握手的具体实现细节

### 三次握手的SYN与ACK情况

SYN用作对序号初始化的同步，双方第一次发送报文时都会发送带有SYN位的报文，表示初始化序号同步。接收到SYN报文之后一定会返回一个带有ACK位的报文，表示已收到上次的SYN报文，因为SYN报文占一个序号，所以ACK的值就会返回x+1

## 一些额外的问题

### SYN报文

SYN报文是一种特殊的报文。因为SYN标志位仅仅只在建立连接时才会使用，所以一般来说一个报文中看到SYN位为1，一般就是建立连接所发的报文。

### ACK报文

TCP对于ACK标志位的规定：当建立连接时ACK标志位根据情况来规划（三次握手），当连接建立后，ACK位常1（因此特性，可以用来判断报文是否有效）。因为ACK表示发送方所收到对面报文的情况，所以被用作收到确认，表示“我”正确收到了“你”所发的报文，然后表达“我”收到的最后的序号是什么。

### 为什么要初始化序号（ISN）

### 数据携带问题

### SYN攻击

# WireShark 三次握手

## 第一次握手

![[image-20221027141822323.png]]

Sequence Number=0 初始化序号
Flags=0x002 标志（小端序？）
![[image-20221027144317974.png]]

## 第二次握手

![[image-20221027151652106.png]]

Sequence Number=0 初始化序号
Acknowledgment Number=1 确认序号

![[image-20221027151829320.png]]

## 第三次握手

![[image-20221027152046464.png]]

Acknowledgment Number=1 确认序号
![[image-20221027152209540.png]]

# 四次挥手

## 第一次挥手

客户端向服务端发送FIN报文（FIN标志位为m的包），关闭客户端到服务端的数据传输
客户端进入**FIN_WAIT_1**状态，代表单方向数据传输完毕或终止传输

## 第二次挥手

服务端收到FIN报文，先向客户端发送ACK报文（ack=m+1）表示已接收到客户端发送过来的FIN包
然后服务端进入**CLOSE_WAIT**状态，因为只是客户端单方面关闭连接，服务端要发送给客户端的报文可能还没发完，所以没有完全关闭连接
客户端接收到服务端发送过来的ACK报文之后进入**FIN_WAIT_2**状态，继续等待服务端发送其他的报文

## 第三次挥手

服务端完成所有发送，可以断开连接，向客户端也发送一个FIN报文（FIN位=n）表示请求断开连接
此时，服务端进入**LAST_ACK**状态

## 第四次挥手

客户端收到FIN报文，向服务端发送ACK报文（ack=n+1）表示已经收到服务端发过来的FIN报文，然后进入**TIME_WAIT**状态，服务端收到ACK报文之后，连接断开。
客户端在发送完成FIN报文之后，若2MSL后没有收到回复，则证明服务端已完成关闭。四次挥手完成。

# 对于四次挥手的理解

不同于三次握手，挥手有四次，主要是第二次和第三次
三次挥手可以理解为：
- 第一次发送客户端SYN，表示客户端希望与服务端建立连接连接，SYN代表初始序号
- 第二次服务端回送ACK，代表同意建立连接，回送SYN初始序号，因为是双全工，服务端也要向客户端发送数据，所以服务端也要向客户端发送用来建立连接的初始序号。
- 第三次客户端回送ACK，表示同意连接。

但是断开连接不同，建立连接第二次握手：服务端此时一定相对于客户端是空闲的（因为还没建立连接），断开连接时客户端已经向服务端发送完信息了，但服务端可能还在向客户端发送信息，所以挥手第二次和第三次不能放在同一个包里发。

**如果没有数据发，那么是不是第二次和第三次挥手可以合并？**
正确的，抓包的时候也会见到{FIN,ACK}的情况。
TCP中有一个特性：延迟确认，就是TCP在收到数据时，不需要马上发送ACK而延迟发送的特性。在这种特性下，ACK和FIN就可能合到一个包里面。