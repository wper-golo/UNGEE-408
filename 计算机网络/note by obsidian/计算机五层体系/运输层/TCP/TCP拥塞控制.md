#TCP #运输层 #笔记 #拥塞控制

## 拥塞
在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫**拥塞**。如果不对拥塞进行控制，整个网络的**吞吐量**就要下降。
> 计算机网络中，链路容量（带宽）、交换结点中的缓存和处理机等，都是网络的资源

![[image-20221219160420420.png]]

导致网络拥塞的因素：
- 点的缓存容量太小
- 链路的容量不足（带宽太小）
- 处理机处理的速率太慢
- 拥塞本身会进一步加剧拥塞（恶性循环）

## 拥塞控制的实现

### 如何实现趋近于理想的拥塞控制呢
- 发生网络拥塞的前兆是**分组丢失**，但这不是原因
- 能够实现拥塞控制的前提：网络能够承载现有的网络负荷
- 网络拥塞的控制是一个**动态问题**
- 许多情况下，**拥塞控制本身**成为了网络性能恶化、甚至发生死锁的原因。

### 现有的拥塞控制的两种思路的实现

- 开环控制
	- 设计网络时，就事先考虑周全，力求工作时不发生拥塞
	- 思路：**力争避免发生网络拥塞**
- 闭环控制
	- 基于反馈环路的概念。根据网络当前的运行状态采取相应控制措施
	- 思路：**在发生拥塞后，采取措施进行控制，消除拥塞**

### 网络拥塞的监测

主要指标：
- 由于缺少缓存空间而被丢弃的分组的百分数
- 平均队列长度
- 超时重传的分组数
- 平均分组时延
- 分组时延的标准差
等等

### 拥塞控制的算法

主要四种算法，也是整体流程
- 慢开始（slow-start）
- 拥塞避免（congestion avoidance）
- 快重传（fast retransmit）
- 快恢复（fast recovery）

假设前提条件：
- 数据是单方向传送，而另一个方向只传送确认
- 接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络
- 以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位

#### 拥塞窗口

发送方维护一个称为**拥塞窗口cwnd**的状态变量，其值取决于网络的拥塞程度，并且是动态变化的
- 只要网络没有拥塞，那么拥塞窗口就大一点；网络发生拥塞，拥塞窗口就小一点
- 判断网络拥塞的依据：没有按时收到应当到达的确认报文（即发生了**超时重传**）
发送方将拥塞窗口作为**发送窗口swnd**，即swnd = cwnd
>真正的发送窗口值 = Min(滑动窗口值，拥塞窗口值)

慢开始门限ssthresh状态变量
- 当cwnd < ssthresh时，使用慢开始算法
- 当cwnd > ssthresh时，停止使用慢开始算法，改用拥塞避免算法
- 当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法

>区分
>rwnd  滑动窗口
>cwnd  拥塞窗口
>swnd  发送窗口
>swnd = min(rwnd, cwnd)

#### 慢开始和拥塞避免

##### 慢开始  slow-start
- 目的：用来确定网络的负载能力或拥塞程度
- 算法思路：由小到大逐渐增大拥塞窗口
- 两个变量
	- 拥塞窗口cwnd：初始值
		- 1至2个最大报文段（旧标准）
		- 2值4个最大报文段（RFC 5681）
	- 慢开始门限ssthresh
		- 防止拥塞窗口增大引起网络拥塞
![[image-20221219215549747.png]]
![[image-20221219215455528.png]]
>即刚开始发送按照拥塞窗口的初始值设定
>一轮即发送方发送到接收到确认报文段这一段来回的时间
>每经过一轮，拥塞窗口即加倍，直至慢开始门限

##### 拥塞避免  congestion avoidance
- 思路：让拥塞窗口cwnd慢慢增大，避免出现拥塞
- 每经过一个传输轮次，拥塞窗口cwnd = cwnd + 1，使拥塞窗口cwnd按线性规律缓慢增长
- 在拥塞避免阶段，具有“加法增大”（Additive Increase）的特点
![[image-20221219220612933.png]]
>从慢开始阶段，当到达慢开始门限值时，进入拥塞避免的阶段

如果此时发生了网络拥塞
![[image-20221219220812354.png]]
>拥塞的判断是靠重传计时器实现的，发生丢包，如果没有及时重传，说明网络可能发生了拥塞
>发生拥塞之后，将慢开始门限值降为发生拥塞时的swnd值的一半，同时将swnd值归零，重新开始拥塞流程
![[image-20221219221201320.png]]

慢开始和拥塞避免整体流程
![[image-20221219221254299.png]]
>注意慢开始与拥塞避免的含义

#### 快重传和快恢复

慢开始和拥塞避免是1998年提出的TCP拥塞控制算法（TCP Tahoe版本）
1990年又增加两个新的拥塞控制算法（用以改进TCP的性能），这就是快重传和快恢复（TCP Reno版本）

##### 原有的问题

有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞，这会导致发送方超时重传，误认为网络发生了拥塞，启动慢开始与拥塞避免机制，**降低了传输效率**

为提高效率，采取了快重传与快恢复算法

快重传可以**让发送方尽早知道发生了个别报文段的丢失**，就是让发送方尽快进行重传，而不是等待超时计时器。
- 要求接收方不要等待发送方发送数据时才对数据进行确认，要**立即发送确认**
- 即使收到失序的报文段也要立即发出对已收到报文的**重复确认**
- 发送方一旦**收到三个连续的重复确认**，就将相应的报文段**立即重传**，而不是等待超时重传计时器

>原有的问题本质上就是利用了重传计时器导致
>重传计时器是发送方用来判断报文段有没有到达接收方
>如果正确到达接收方，接收方会在时间段内返回一个ACK报文段表示正确收到
>如果报文段在传输过程中因**拥塞原因导致滞留**或**直接丢失**，接收方会在规定时间内无法返回ACK报文段，说明网络拥塞或丢包
>快重传就是解决了这个问题

##### 快重传
![[image-20221219223143178.png]]

##### 快恢复
![[image-20221219223204578.png]]
>快恢复只是比慢开始快了不少，但还是会变慢，因为拥塞窗口减半了（**不再是归零并从慢开始开始了**），下一次拥塞重新慢开始的时候会更慢（因为ssthresh也减半了）


#### 拥塞控制的整体流程
![[image-20221219223341622.png]]






